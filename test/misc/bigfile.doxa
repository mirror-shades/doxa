/////
//IMPORTS
/////

// modules
module safeMath from "./safeMath.doxa";

// complex import statement
var import1 is safeMath.safeAdd(15, 66);
import1?; // 81
var import2 is safeMath.safeAdd(1000, 2); // "Overflow"
import2?; // -1

// imports
import imported_function, imported_function_input from "./import.doxa";
import imported_function_output from "./import.doxa";

imported_function();
imported_function_input(60);
imported_function_output()?;

/////
// ENUMS, MATCH
/////
enum Color {
    Red,
    Green,
    Blue,
}

const b :: Color is .Blue;
const g :: Color is .Green;

var matchResult is match b {
    .Red then "It's red",
    .Blue then "It's blue",
    else "It's something else",
}; 

matchResult?; // It's blue

matchResult is match g {
    .Red then "It's red",
    .Blue then "It's blue",
    else "It's something else",
};

matchResult?; // It's something else

/////
// fnS AND LOOPS / RECURSION
/////
fn fizzbuzz(x:: int, limit:: int) {
    var current is x;
    while current <= limit {
        if current % 3 equals 0 and current % 5 equals 0 then "fizzbuzz"?;
        else if current % 3 equals 0 then "fizz"?;
        else if current % 5 equals 0 then "buzz"?;
        else current?;
        
        current += 1;
    }
}

fizzbuzz(100, 115);//fizzbuzz 1-15


fn fber(x:: int, limit:: int) {
    if x % 3 equals 0 and x % 5 equals 0 then "fizzbuzzer"?;
    else if x % 3 equals 0 then "fizzer"?;
    else if x % 5 equals 0 then "buzzer"?;
    else x?;

    if x < limit then fber(x + 1, limit);
}

fber(1000, 1015); //fizzerbuzzer 1-15

fn forloop(x :: int) {
    for (var i is 0; i < x; i++) {
        ((i+10)*66)?;
    }
}

forloop(5); //660, 726, 732, 798, 864

/////
// CONDITIONALS
/////

var mixedBranch1 is if true then {
    var notUsed is 10 + 5;
    "true";
} else "false";

mixedBranch1?; // true

var mixedBranch2 is if false then {
    var notUsed is 10 + 5;
    "true";
} else "false";

mixedBranch2?; // false

var stringArr is ["hello", "world", "foo", "bar"];

each word at index in stringArr {
    index?;
    word?;
}

var asThenUnion :: int | float | byte is 10;
var asThen is asThenUnion as int else 0;

asThen?; // 10

var asThen2 is asThenUnion as int then 20 else 0;

asThen2?; // 20

var asThen3 is asThenUnion as int then {10 + 20;} else 0;

asThen3?; // 30

var asThen4 is asThenUnion as float then 40.0 else { 0.0; }

asThen4?; // 0.0

// using as like an 'istype' style conditional
asThenUnion as int then {
    var result is 20 + 30;
    result?;
} else {
    var result is 30 + 40;
    result?;
}; // 50


asThenUnion?; // 10
asThenUnion is 10.0;
asThenUnion?; // 10.0
asThenUnion is 0x0A;
asThenUnion?; // 0x0A

// as narrowing
fn onlyUsesInt(x :: int) {
    x?;
    return;
}

const x :: int | float is 17;

x as int then onlyUsesInt(x) else "failure"?;

// return statements
fn return_test() -> string {
    return "return";
}

return_test()?; // return

// implicit return statements
fn implicit_return_test() -> string {
    "implicit";
}

implicit_return_test()?; // implicit

/////
// STRUCTS AND BYTES
/////
struct Person {
    name :: string,
    age :: int,
}

struct Employee {
    person ::  Person,
    salary :: int,
}

var mike is Employee {
    person is Person {
        name is "Mike",
        age is 25,
    },
    salary is 1000,
};

mike.person.age is 26;
mike.person.age?; // 26
//testing length method
@length(mike.person.name)?;
//testing bytes method
@bytes(mike.person.name)?;
// testing index method
mike.person.name[0]?; // M
// testing bytes print and bytes index
@bytes(mike.person.name)[0]?; // 77

mike.salary?; // 1000

/////
// TETRAS AND CONTRADICTIONS
/////
var firstFold :: tetra is true;
var secondFold :: tetra is false;
var thirdFold :: tetra is both;
var fourthFold :: tetra is neither;

firstFold?;
secondFold?;
thirdFold?;
fourthFold?;    

//both is both true and false
(both equals true and both equals false)?; // true
//neither is neither true or false
(neither equals true or neither equals false)?; // false

const Bob is true;
const Shakespere is false;
const zombie is both;
const angel is neither;

fn living(alive :: tetra) {
    if alive then "I am alive"?;
    if not alive then "I am dead"?;
}

living(Bob); // I am alive
living(Shakespere); // I am dead
living(zombie); // I am alive; I am dead
living(angel); // 


/////
// ARRAYS
/////
var arr :: int[] is [111111, 222222, 333333, 444444, 555555];

arr?;
arr[3]?; // 444444
arr[3] is 666666;
arr[3]?; // 666666
@push(arr, 420000); // TODO: all array methods should use the @ syntax
arr[5]?; // 420000

const checkAgainst is 333333;

var initArr :: int[10];
var floatArr :: float[10];
var byteArr :: byte[10];
var tetraArr :: tetra[10];
var strArr :: string[10];

initArr[0]?;
initArr[9]?;

floatArr[0]?;
floatArr[9]?;

byteArr[0]?;
byteArr[9]?;

tetraArr[0]?;
tetraArr[9]?;

strArr[0]?;
strArr[9]?;


// quantifiers
var ex is exists e in arr where e > checkAgainst;

ex?; // true

var uni is forall u in arr where u > checkAgainst;
uni?; // false

/////
// CONDITIONALS
/////
var condition is if true then "true" else "false";
condition?; // true



/////
// DEFAULT ARGUMENTS
/////
fn foo(a :: int, b :: int is 5) -> int {
    return a+b;
}

foo(777, 2)?; // 779
foo(777, ~)?; // 782

/////
// UNION TYPES
/////

const un1 :: int | float is 3;
const un2 :: int | float is 3.5;

fn process_number_union_string(value :: int | float) -> string {
    return match value {
        int then "integer",
        float then "float",
    };
}

process_number_union_string(un1)?; // integer
process_number_union_string(un2)?; // float

fn process_number_union_narrow(value :: int | float) -> int {
    return match value {
        int then value,
        float then 0,
    };
}

process_number_union_narrow(un1)?; // 3
process_number_union_narrow(un2)?; // 0

fn process_number_union_int(value :: int | float) -> int {
    return value as int else 0;
}

process_number_union_int(un1)?; // 3
process_number_union_int(un2)?; // 0

fn process_number_union_return_union(value :: int | float) -> int | float {
    return value;
}

const newun :: int | float is process_number_union_return_union(un1);

const resint is newun as int else 0; // integer
const resfloat is newun as float else 0; // float

resint?; // 3
resfloat?; // 0

/////
// MAPS
/////
var Map is {
    "a": 1.5,
    "b": 2.5,
    "c": 3.5,
};

Map["a"]?; // 1.5
Map["c"]?; // 3.5

/////   
// FORMAL LOGICAL NOTATION
/////
(∃x ∈ arr : x > checkAgainst)?; // true  67
(∀x ∈ arr : x > checkAgainst)?; // false  68
(¬∀x ∈ arr : x > checkAgainst)?; // true  69
(false ↔ false)?; // true  70
(true ⊕ true)?; // false  71
(true ∧ false)?; // false  72
(true ∨ false)?; // true  73
(true ↑ false)?; // true  74
(true ↓ false)?; // false  75
(true → false)?; // false  76


// werid formatting
(
    
    true) 
    ?
; // true

/////
// @type AND INFERENCE
/////

var _int :: int;
_int?; // 0

var _float :: float;
_float?; // 0.0

var _byte :: byte;
_byte?; // 0x00

var _tetra :: tetra;
_tetra?; // false

var _string :: string;
_string?; // ""

@type(_int)?; // int

@type(_byte)?; // byte

@type(_float)?; // float

@type(_string)?; // string

@type(_tetra)?; // tetra

@type(arr)?; // array

@type(Employee)?; // struct
@type(mike)?; // Employee

@type(Color)?; // enum
@type(Color.Blue)?; // Color

@type(Map)?; // map