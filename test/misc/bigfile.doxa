/////
//IMPORTS
/////

// modules
module safeMath from "./safeMath.doxa"

// complex import statement
var import1 is safeMath.safeAdd(15, 66)
import1? // 81
var import2 is safeMath.safeAdd(1000, 2) // "Overflow"
import2? // -1

// imports
import imported_function, imported_function_input from "./import.doxa"
import imported_function_output from "./import.doxa"

imported_function()
imported_function_input(60)
imported_function_output()?

/////
// ENUMS, MATCH
/////
enum Color {
    Red,
    Green,
    Blue,
}

const b :: Color is .Blue
const g :: Color is .Green

var matchResult is match b {
    .Red then "It's red",
    .Blue then "It's blue",
    else "It's something else",
}

matchResult? // It's blue

matchResult is match g {
    .Red then "It's red",
    .Blue then "It's blue",
    else "It's something else",
}

matchResult? // It's something else


/////
// LOOPS
/////


// FOR
for f {
    if f != 2 then f?
    f += 1
    if f == 5 then break
}

for f is 5 {
    f -= 1
    if f != 2 then f?
    if f == 0 then break
}


// DO
//empty do body
var do_empty is 0
do {
    if do_empty != 2 then do_empty?
    do_empty += 1
    if do_empty == 5 then break
}

// do bodys
var do_body is 0
do do_body += 1 {
    if do_body == 2 then continue
    if do_body == 5 then break
    do_body?
}

// WHILE
// WHILE ONLY
var _while is 0
while _while < 5 {
    if _while == 5 then break
    if _while != 2 then _while?
    _while += 1
}

// WHILE DO
var while_do is 0
while while_do < 5 do {
    while_do += 1
} {
    if while_do == 5 then break
    if while_do != 2 then while_do?
}

// FOR DO
for for_do do for_do += 1 {
    if for_do == 5 then break
    if for_do != 2 then for_do?
}

// FOR WHILE DO
// default loop variable
for for_while_do_empty while for_while_do_empty < 5 do for_while_do_empty += 1 {
    if for_while_do_empty != 2 then for_while_do_empty?
}

// manually set the loop variable
for for_while_do is 10 while for_while_do > 0 do for_while_do -= 1 {
    if for_while_do % 2 == 0 then for_while_do?
}

// EACH
var collection is [0, 1, 2, 3, 4]

each item in collection {
    if item == 2 then continue
    item?
}

each item at index in collection {
    if index == 2 then continue
    index?
    item?
}



/////
// ALIASING
/////
var inc1 is 10
var inc2 is 20

function noincrement(param :: int) {
    param += 1
}

function increment(^param :: int) {
    param += 1
}

noincrement(inc1)
inc1?

increment(^inc1)
inc1?

function increment_second(param1 :: int, ^param2 :: int) {
    param1 += 1
    param2 += 1
}

increment_second(inc1, ^inc2)
inc1?
inc2?

function increment_function_scope(param1 :: int) {
    increment(^param1)
    param1?
}

increment_function_scope(inc1)
inc1?


/////
// FUNCTIONS AND RECURSION
/////
function fizzbuzz(x:: int, limit:: int) {
    var current is x
    while current <= limit {
        if current % 3 == 0 and current % 5 == 0 then "fizzbuzz"?
        else if current % 3 == 0 then "fizz"?
        else if current % 5 == 0 then "buzz"?
        else current?
        
        current += 1
    }
}

fizzbuzz(100, 115) //fizzbuzz 1-15


function fber(x:: int, limit:: int) {
    if x % 3 == 0 and x % 5 == 0 then "fizzbuzzer"?
    else if x % 3 == 0 then "fizzer"?
    else if x % 5 == 0 then "buzzer"?
    else x?

    if x < limit then fber(x + 1, limit)
}

fber(1000, 1015) //fizzerbuzzer 1-15

function forloop(x :: int) {
    for i is 0 while i < x do i++ {
        ((i+10)*66)?
    }
}

forloop(5) //660, 726, 732, 798, 864

function precedence(op :: string[]) {
    var list is op
    while @length(list) > 0 {
        var x is @pop(list)
        const res is match x {
            "+" then 1,
            "-" then 1,
            "*" then 2,
            "/" then 2,
            else -1,
        }
        res?
        x?
    }
}

precedence(["*", "+", "-", "=", "/"])


/////
// CONDITIONALS
/////

var mixedBranch1 is if true then {
    var notUsed is 10 + 5
    "true"
} else "false"

mixedBranch1? // true

var mixedBranch2 is if false then {
    var notUsed is 10 + 5
    "true"
} else "false"

mixedBranch2? // false

var stringArr is ["hello", "world", "foo", "bar"]

each word at index in stringArr {
    index?
    word?
}

var condition is if true then "true" else "false"
condition? // true


/////
// UNION NARROWING 
/////

var asThenUnion :: int | float | byte is 10
var asThen is asThenUnion as int else 0

asThen? // 10

var asThen2 is asThenUnion as int then 20 else 0

asThen2? // 20

var asThen3 is asThenUnion as int then {10 + 20} else 0

asThen3? // 30

var asThen4 is asThenUnion as float then 40.0 else { 0.0 }

asThen4? // 0.0

// using as like an 'istype' style conditional
asThenUnion as int then {
    var result is 20 + 30
    result?
} else {
    var result is 30 + 40
    result?
} // 50


asThenUnion? // 10
asThenUnion is 12.345
asThenUnion? // 10.0
asThenUnion is 0x0A
asThenUnion? // 0x0A

// as narrowing
function onlyUsesInt(x :: int) {
    x?
}

const x :: int | float is 17

x as int then onlyUsesInt(x) else "failure"?


/////
// RETURNS 
/////
function return_test() returns string {
    return "return"
}

return_test()? // return

/////
// STRUCTS
/////
struct Person {
    pub name :: string,
    pub age :: int,
}

struct Employee {
    pub person ::  Person,
    pub salary :: int,
}

var mike is Employee {
    person is Person {
        name is "Mike",
        age is 25,
    },
    salary is 1000,
}

mike.person.age is 26
mike.person.age? // 26
//testing length method
@length(mike.person.name)?
// testing index method
mike.person.name[0]? // M
// testing byte print and byte index
@byte(mike.person.name[0])? // 77

mike.salary? // 1000


struct Point {
    x :: int,
    y :: int,

    pub function New(x :: int, y :: int) returns Point {
        return Point {
            x is x,
            y is y,
        }
    }

    pub method getX() { // methods are always instance methods with implicit 'this'
        return this.x
    }

    pub method getY() {
        return this.y
    }

    pub function safeSub(a :: int, b :: int) returns int { // functions are always static
        const result is a - b
        if result > 255 or result < 0 then return -1
        return result
    }

    pub method getDelta() returns int {
        return Point.safeSub(this.x, this.y)
    }
}

var point is Point.New(5, 2)
point?
point.getX()?
point.getY()?
Point.safeSub(10, 2)?
Point.safeSub(2, 10)?
point.getDelta()?



/////
// TETRAS AND CONTRADICTIONS
/////
var firstFold :: tetra is true
var secondFold :: tetra is false
var thirdFold :: tetra is both
var fourthFold :: tetra is neither

firstFold?
secondFold?
thirdFold?
fourthFold?

//both is both true and false
(both == true and both == false)? // true
//neither is neither true or false
(neither == true or neither == false)? // false

const Bob is true
const Shakespere is false
const zombie is both
const angel is neither

function living(alive :: tetra) {
    if alive then "I am alive"?
    if not alive then "I am dead"?
}

/* 
expected output:
I am alive // from Bob
I am dead  // from Shakespere
I am alive // from zombie
I am dead  // from zombie
           // no trigger from angel
*/

living(Bob)
living(Shakespere) 
living(zombie) 
living(angel) 



/////
// ARRAYS
/////
var arr :: int[] is [111111, 222222, 333333, 444444, 555555]

arr?
arr[3]? // 444444
arr[3] is 666666
arr[3]? // 666666
@push(arr, 420000) // TODO: all array methods should use the @ syntax
arr[5]? // 420000
@pop(arr)? //42000
arr? //

var arr_part_one is [1, 2, 3]
var arr_part_two is [4, 5, 6]

(arr_part_one + arr_part_two)?

const bigArr is [1,2,3] + [4,5,6]
bigArr?

const checkAgainst is 333333

var initArr :: int[10]
var floatArr :: float[10]
var byteArr :: byte[10]
var tetraArr :: tetra[10]
var strArr :: string[10]

initArr[0]?
initArr[9]?

floatArr[0]?
floatArr[9]?

byteArr[0]?
byteArr[9]?

tetraArr[0]?
tetraArr[9]?

strArr[0]?
strArr[9]?

/////
// ARRAY OF STRUCT
/////

enum Species {
    FROG,
    WHALE,
    PENGUIN,
    HIPPO,
    LION,
}

struct Animal {
    pub animal_type :: Species,
    pub name :: string,
}

const zoo :: Animal[] is [
    Animal { 
        animal_type is Species.LION,
        name is "Fluffy",
     },
    Animal { 
        animal_type is Species.PENGUIN,
        name is "Sam",
     },
    Animal { 
        animal_type is Species.WHALE,
        name is "Nemo",
     },
]

zoo[0].name?
zoo[0].animal_type?
zoo[1].name?
zoo[1].animal_type?
zoo[2].name?
zoo[2].animal_type?


/////
// DEFAULT ARGUMENTS
/////
function foo(a :: int, b :: int is 5) returns int {
    return a+b
}

foo(777, 2)? // 779
foo(777, ~)? // 782

/////
// UNION TYPES
/////

const un1 :: int | float is 3
const un2 :: int | float is 3.5

function process_number_union_string(value :: int | float) returns string {
    return match value {
        int then "integer",
        float then "float",
    }
}

process_number_union_string(un1)? // integer
process_number_union_string(un2)? // float

function process_number_union_narrow(value :: int | float) returns int {
    return match value {
        int then value,
        float then 0,
    }
}

process_number_union_narrow(un1)? // 3
process_number_union_narrow(un2)? // 0

function process_number_union_int(value :: int | float) returns int {
    return value as int else 0
}

process_number_union_int(un1)? // 3
process_number_union_int(un2)? // 0

function process_number_union_return_union(value :: int | float) returns int | float {
    return value
}

const newun :: int | float is process_number_union_return_union(un1)

const resint is newun as int else 0 // integer
const resfloat is newun as float else 0 // float

resint? // 3
resfloat? // 0

/////
// MAPS
/////
var map MyMap {
    "a" is 1.5,
    "b" is 2.5,
    "c" is 3.5,
}

MyMap["a"]? // 1.5
MyMap["c"]? // 3.5
MyMap["c"] is 4.5 
MyMap["c"]? // 4.5



const map MyMap2 {
    15 is "fifteen",
    16 is "sixteen",
    17 is "seventeen",
}

MyMap2[15]? // fifteen
MyMap2[17]? // seventeen

var map MyMap_typed0 returns string {
    1 is "one",
    2 is "two",
    3 is "three",
}

MyMap_typed0[1]? // one
MyMap_typed0[2]? // two

var map MyMap_typed1 :: int {
    1 is "one",
    2 is "two",
    3 is "three",
}

MyMap_typed1[1]? // one
MyMap_typed1[2]? // two

var map MyMap_typed2 :: int returns string {
    1 is "one",
    2 is "two",
    3 is "three",
}

MyMap_typed2[1]? // one
MyMap_typed2[2]? // two

var map MyMap_enum :: Color returns string {
    .Red is "red",
    .Green is "green",
    .Blue is "blue",
}

MyMap_enum[.Red]? // red
MyMap_enum[.Blue]? // blue

var map MyMap_struct {
    1 is mike,
}

MyMap_struct[1].person.name? // Mike
MyMap_struct[1].salary? // 1000


/////
// RANGE
/////
var range1 is 1 to 6
range1?

var range2 is 0 to 3
range2?

var range3 is 5 to 2
range3?

var range4 is 10 to 10
range4?


/////   
// FORMAL LOGICAL NOTATION
/////
(∃x ∈ arr : x > checkAgainst)? // true 
(∀x ∈ arr : x > checkAgainst)? // false 
(¬∀x ∈ arr : x > checkAgainst)? // true 
(false ↔ false)? // true  70
(true ⊕ true)? // false  71
(true ∧ false)? // false  72
(true ∨ false)? // true  73
(true ↑ false)? // true  74
(true ↓ false)? // false  75
(true → false)? // false  76


// quantifiers
var ex is exists e in arr where e > checkAgainst

ex? // true

var uni is forall u in arr where u > checkAgainst
uni? // false


/////
// LINE BREAKS
/////

const brokenLine is 42 - 
... 100

brokenLine?

// explicit line breaks with semicolon
living(Bob); living(Shakespere); living(zombie); living(angel); 


/////
// @type AND INFERENCE
/////

var _int :: int
_int? // 0

var _float :: float
_float? // 0.0

var _byte :: byte
_byte? // 0x00

var _tetra :: tetra
_tetra? // false

var _string :: string
_string? // ""

"end"?