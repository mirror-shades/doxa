module g from "graphics"

const rl is g.raylib
const dg is g.doxa

const WIDTH is 800
const HEIGHT is 600
const FPS is 60
const NAME is "Working Graphics Demo"

struct Circle {
    pub x :: int
    pub y :: int
    pub x_speed :: int
    pub y_speed :: int
    pub radius :: int
}

entry function main() {
    // doxa has a simplified API for initializing graphics
    // Initialize graphics (defers CloseWindow automatically)
    dg.Init(WIDTH, HEIGHT, FPS, NAME)
    
    var frame_count :: int is 0
    var shift :: byte is 0x80   
    var up :: tetra is true

    var circle is Circle {
        x is @int(WIDTH / 2) as int else 0,
        y is @int(HEIGHT / 2) as int else 0,
        x_speed is 3,
        y_speed is 3,
        radius is 30,
    }
    
    while dg.Running() {
        // Begin drawing (defers EndDrawing automatically)
        dg.Draw()
        drawBackground(circle, frame_count)
        drawCircle(^circle, frame_count, ^shift, ^up)
        frame_count is frame_count + 1
    }    
}

// circle is passed by value because we don't need to mutate the original circle
function drawBackground(circle :: Circle, frame_count :: int) {
    // the background colour changes based on the direction the circle is moving
    if circle.x_speed > 0 then {
        if circle.y_speed > 0 then {
            const color is dg.bytesToColor(0x22, 0x32, 0x50, 0xFF)
            rl.ClearBackground(color)
        } else {
            const color is dg.bytesToColor(0x22, 0x42, 0x60, 0xFF)
            rl.ClearBackground(color)
        }
    } else {
        if circle.y_speed > 0 then {
            const color is dg.bytesToColor(0x22, 0x52, 0x80, 0xFF)
            rl.ClearBackground(color)
        } else {
            const color is dg.bytesToColor(0x22, 0x62, 0x70, 0xFF)
            rl.ClearBackground(color)
        }
    }
}

// circle is aliased because we need to mutate the original circle
function drawCircle(^circle :: Circle, frame_count :: int, ^shift :: byte, ^up :: tetra) {
    // Reverse the speed when the circle hits the edges of the screen
    if circle.x > (WIDTH - circle.radius) or circle.x < circle.radius then {  
        circle.x_speed is -circle.x_speed
    }
    @print("top at {HEIGHT}\n")
    if circle.y > (HEIGHT - circle.radius) or circle.y < circle.radius then {
        circle.y_speed is -circle.y_speed   
    }

    // Update the position of the circle
    circle.x is circle.x + circle.x_speed
    circle.y is circle.y + circle.y_speed

    // Colour of the circle shifts around continuously
    if (up) then {
        shift += 0x01
    } else {
        shift -= 0x01
    }
    if (shift == 0xFF or shift == 0x00) then {
        up is not up
    }

    // draw the circle with raylib
    const color is dg.bytesToColor(0xAA, 0x22, shift, 0xFF)
    rl.DrawCircle(circle.x, circle.y, circle.radius, color)
}
