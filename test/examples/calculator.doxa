enum TokenType {
    NUMBER,
    OPERATOR,
    LPAREN,
    RPAREN,
}

struct Token {
    token_type :: TokenType,
    value :: string,
}

function precedence(op :: string) returns int {
    return match op {
        "(" then 0,
        ")" then 0,
        "+" then 1,
        "-" then 1,
        "*" then 2,
        "/" then 2,
        else -1,
    }
}

entry function main() {
    // Test the full calculator with an expression
    "Starting calculator"?
    const input is "5 + 6"
    "Input: " + input?
    const splitInput is split(input)
    "After split"?
    @assert(verifyParens(splitInput), "parens don't match")
    "After paren check"?
    const possibleTokens is tokenize(splitInput)
    "After tokenize"?

    possibleTokens as Token[] then {
        "current tokens: " + possibleTokens)?
        "Got tokens, calling shunt"?
        const rpn is shunt(possibleTokens)
        "After shunt"?
        rpn as Token[] then {
            "Got RPN, calling execute"?
            execute(rpn)
            "After execute"?
        } else {
            "shunting failed"?
        }
    } else {
        "tokens failed to parse"?
    }
}

function split(input :: string) returns string[] {
    var result :: string[]
    var current is ""

    const lin is @length(input)

    // `each` loops iterate through each element
    // they can work on strings as well as arrays
    // `at` is optional syntax for a loop index
    each c at i in input {
        // breaks number if operator is found
        if c == " " then {
            if current != "" then {
                @push(result, current)
                current is ""
            }
        }

        else if c == "+" or c == "*" or c == "/" or c == "(" or c == ")" then {
            if current != "" then {
                @push(result, current)
                current is ""
            }
            @push(result, c)
        }

        // make sure - isn't a negative sign
        else if c == "-" and input[i+1] == " " then {
            if current != "" then {
                @push(result, current)
                current is ""
            }
            @push(result, c)
        } 

        else if c != " " {
            current is current + c
        }

    }
    @push(result, current)
    return result
}

function verifyParens(input :: string[]) returns tetra {
    var depth is 0
    var passed :: tetra is true
    each s in input {
        if s == "(" then depth += 1
        if s == ")" then depth -= 1
        if depth < 0 then {
            passed is false
        }
    }
    if depth > 0 then {
        passed is false
    }
    return passed
}

function tokenize(input :: string[]) returns Token[] | nothing {
    var tokens :: Token[]

    each token in input {
        if token == "+" or token == "-" or token == "*" or token == "/" then {
            @push(tokens, Token {
                token_type is .OPERATOR,
                value is token,
            })
        }
        else if token == "(" then {
            @push(tokens, Token {
                token_type is .LPAREN,
                value is token,
            })
        }
        else if token == ")" then {
            @push(tokens, Token {
                token_type is .RPAREN,
                value is token,
            })
        } else {
            @push(tokens, Token {
                token_type is .NUMBER,
                value is token,
            })
        }
    }
    return tokens
}

function shunt(tokens :: Token[]) returns Token[] | nothing {
    var output :: Token[]
    var operators :: Token[]

    each token in tokens {
        "Processing token in shunt"?
        token.token_type?
        if token.token_type == TokenType.NUMBER then {
            "Pushing number to output"?
            @push(output, token)
        }

        else if token.token_type == TokenType.OPERATOR then {
            "Processing operator"?
            // pop higher or equal precedence ops onto output
            while @length(operators) > 0 {
                "In operator while loop, operators length: " + @length(operators)?
                const top is operators[@length(operators) - 1]
                "Top operator: " + top.value?
                "Current token: " + token.value?
                if top.token_type == TokenType.OPERATOR and precedence(top.value) >= precedence(token.value) then {
                    "Popping operator to output"?
                    @push(output, top)
                    @pop(operators)
                    "After pop, operators length: " + @length(operators)?
                } else {
                    "Breaking from operator loop"?
                    break
                    
                }
            }
            "Pushing current operator to operators stack"?
            @push(operators, token)
        }

        else if token.token_type == TokenType.LPAREN then {
            @push(operators, token)
        }

        else if token.token_type == TokenType.RPAREN then {
            // pop until left paren found
            var matched is false
            while @length(operators) > 0 {
                const top is operators[@length(operators) - 1]
                if top.token_type == TokenType.LPAREN then {
                    @pop(operators)
                    matched is true
                    break
                } else {
                    @push(output, top)
                    @pop(operators)
                }
            }
            if !matched then {
                "mismatched parentheses"?
                return nothing
            }
        }
    }

    // All tokens have been processed, now drain remaining operators
    while @length(operators) > 0 {
        const top is operators[@length(operators) - 1]
        if top.token_type == TokenType.LPAREN or top.token_type == TokenType.RPAREN then {
            "mismatched parentheses"?
            return nothing
        }
        @push(output, top)
        @pop(operators)
    }

    // All operators drained, return the result
    return output
}

function execute(tokens :: Token[]) returns int {
    var stack :: int[]

    each token in tokens {
        "Processing token in execute:"?
        token.token_type?
        token.value?
        if token.token_type == TokenType.NUMBER then {
            "Converting number token:"?
            token.value?
            var temp_result is @int(token.value)
            temp_result?
            const n is temp_result as int else {
                "invalid number conversion"?
                return
            }
            "Number conversion successful:"?
            n?
            "Pushing to stack:"?
            @push(stack, n)
        } 


        else if token.token_type == TokenType.OPERATOR then {
            "Processing operator:"?
            token.value?
            "Stack length:"?
            @length(stack)?

            // need two operands
            if @length(stack) < 2 then {
                "not enough operands"?
                return
            }

            "Popping operands:"?
            const right is @pop(stack)
            const left is @pop(stack)

            "Operands:"?
            left?
            right?

            var result :: int is 0

            "Calculating result:"?
            if token.value == "+" then result is left + right
            else if token.value == "-" then result is left - right
            else if token.value == "*" then result is left * right
            else if token.value == "/" then result is @floor(left / right)
            else {
                token.value?
                "invalid operator"?
                return
            }

            "Result:"?
            result?
            @push(stack, result)
        }
    }

    if @length(stack) != 1 then {
        "invalid expression"? 
        return
    }

    stack[0]?
    return stack[0]
}