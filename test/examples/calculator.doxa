enum Error {
    INVALID_TOKEN,
}

enum TokenType {
    NUMBER,
    OPERATOR,
    PARENTHESIS,
}

struct Token {
    type :: TokenType,
    value :: string,
}

entry fn main() {
    const input is @input();
    input?;

    const splitInput is split(input);
    splitInput?;

    const tokens is tokenize(splitInput);
    tokens?;

    return;
}

fn split(input :: string) -> string[] {
    var result :: string[];
    var current is "";

    each c at i in input {
        if @length(current) > 0 and (c equals " " or c equals "+" or c equals "-" or c equals "*" or c equals "/") then {
            @push(result, current);
            current is "";
        }
        
        c?;
        (c equals "+" or c equals "-" or c equals "*" or c equals "/")?;

        if c equals " " then {
            // Skip spaces
        }
        else if c equals "+" or c equals "-" or c equals "*" or c equals "/" then {
            "OPERATOR FOUND"?;
            @push(result, c);
        } else {
            current is current + c;
        }

    }
    @push(result, current);
    return result;
}

fn tokenize(input :: string[]) -> Token[] | Error {
    var tokens :: Token[];

    each token at i in input {
        if token equals "+" or token equals "-" or token equals "*" or token equals "/" then {
            @push(tokens, Token {
                type is TokenType.OPERATOR,
                value is token,
            });
        } 
        else if token equals "(" or token equals ")" then {
            @push(tokens, Token {
                type is TokenType.PARENTHESIS,
                value is token,
            });
        } else {
            @int(token) as int then {
                @push(tokens, Token {
                    type is TokenType.NUMBER,
                    value is token,
                });
            } else {
                return Error.INVALID_TOKEN;
            }
        }
    }
    return tokens;
}