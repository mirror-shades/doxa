const limit :: int is 10000;

function diceRoll() returns int {
    const random_float is @random() * 6 + 1
    return @int(random_float) as int else -1 
}

function add(a :: int, b :: int) returns int {
    return a + b
}

// Dice roll benchmark
function dice_roll_benchmark() {
    var count is 0
    var start_time is @tick()
    
    for i is 1 while i <= limit do i += 1 {
        const roll is diceRoll()
        count is count + roll  // Prevent optimization
    }
    
    var end_time is @tick()
    @print("Dice rolls: {count}, Time: {(end_time - start_time) / 1000000000 }s\n")
}

// FizzBuzz benchmark
function fizzbuzz_benchmark() {
    var start_time is @tick()
    
    for i is 1 while i <= limit do i += 1 {
        if i % 15 == 0 then "FizzBuzz"
        else if i % 3 == 0 then "Fizz" 
        else if i % 5 == 0 then "Buzz"
        else @string(i)
    }
    
    var end_time is @tick()
    @print("FizzBuzz time: {(end_time - start_time) / 1000000000 }s\n")
}

// Arithmetic benchmark
function arithmetic_benchmark() {
    var sum is 0
    var start is @tick()
    
    each i in 1 to limit {
        sum += i * 2 + 1
    }
    
    @print("Arithmetic: {sum}, Time: {(@tick() - start) / 1000000000}s\n")
}

// Function call benchmark  
function call_benchmark() {
    var sum is 0
    var start is @tick()
    
    each i in 1 to limit {
        sum += add(i, i + 1)
    }
    
    @print("Function calls: {sum}, Time: {(@tick() - start) / 1000000000}s\n")
}

// Run all benchmarks
@print("=== DOXA BENCHMARK SUITE ===\n")
dice_roll_benchmark()
fizzbuzz_benchmark()
arithmetic_benchmark()
call_benchmark()





