// Constant folding test - showcases compile-time evaluation
// These expressions should be pre-computed at compile time

// Arithmetic constant folding
var arithmeticResult is 2 + 3 * 4 - 1; // Should fold to 13
arithmeticResult?;

// Comparison constant folding
var comparisonResult is 10 > 5; // Should fold to true
comparisonResult?;

// Logical constant folding using comparison results
var logicalResult is 5 > 3 and 2 < 4; // Should fold to true
logicalResult?;

// Nested expressions with grouping
var nestedResult is (2 + 3) * (4 - 1); // Should fold to 15
nestedResult?;

// Power operation - now with proper parser support!
var powerResult is 2 ** 3; // Should fold to 8
powerResult?;

// Simple division
var divisionResult is 15 / 3; // Should fold to 5
divisionResult?;

// Complex expression mixing multiple operations
var complexResult is (10 + 5) * 2 - 6 / 3; // Should fold to 28
complexResult?;

// Branch elimination - condition is always true
if 5 > 3 then {
    "This branch will always execute"?;
} else {
    "This branch will never execute"?;
}

// Branch elimination - condition is always false  
if 2 > 5 then {
    "This will never execute"?;
} else {
    "This will always execute"?;
}

// Function with constant expressions
function constantMath() {
    var a is 100 + 50 - 25; // Should fold to 125
    var b is a / 5; // Can't fold because a is variable
    return b;
}

constantMath()?;

// More complex nested operations
var result is ((3 + 7) * 2) + (15 / 3); // Should fold to 25
result?;

// Power in complex expressions
var powerComplex is 2 ** 2 + 3 ** 2; // Should fold to 4 + 9 = 13
powerComplex?; 