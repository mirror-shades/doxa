enum TokenType {
    NUMBER,
    OPERATOR,
    LPAREN,
    RPAREN,
}

struct Token {
    token_type :: TokenType,
    value :: string,
}

function precedence(op :: string) returns int {
    return match op {
        "(" then 0,
        ")" then 0,
        "+" then 1,
        "-" then 1,
        "*" then 2,
        "/" then 2,
        "^" then 3,
        else -1,
    }
}

entry function main() {

    const input is "5 + 6"
    ("Input: " + input)??
    
    const splitInput is split(input)
    "Split input:"??
    each s in splitInput {
        s??
    }
    
    const tokens is tokenize(splitInput)
    tokens as Token[] then {
        const rpn is shunt(tokens)
    } else {
        ("Failed to tokenize\n")?
        return
    }
}

function shunt(tokens :: Token[]) returns Token[] | nothing {
    var stack :: Token[]
    var operators :: Token[]
    each t in tokens {
        if t.token_type == TokenType.NUMBER then {
            "number found"??
            @push(stack, t)
        }
        if t.token_type == TokenType.OPERATOR then {
            t.value??
            @type(t.value)??
            precedence(t.value)??
            @push(operators, t)
        }
        if t.token_type == TokenType.RPAREN then "right parentheses found"??
        if t.token_type == TokenType.LPAREN then "left parentheses found"??
    }
    stack??
}

function split(input :: string) returns string[] {
    var result :: string[]
    var current is ""

    const lin is @length(input)

    // `each` loops iterate through each element
    // they can work on strings as well as arrays
    // `at` is optional syntax for a loop index
    each c at i in input {
        // breaks number if operator is found
        if c == " " then {
            if current != "" then {
                @push(result, current)
                current is ""
            }
        }

        else if c == "+" or c == "*" or c == "/" or c == "(" or c == ")" then {
            if current != "" then {
                @push(result, current)
                current is ""
            }
            @push(result, c)
        }

        // make sure - isn't a negative sign
        else if c == "-" and input[i+1] == " " then {
            if current != "" then {
                @push(result, current)
                current is ""
            }
            @push(result, c)
        } 

        else if c != " " {
            current is current + c
        }

    }
    @push(result, current)
    return result
}

function tokenize(input :: string[]) returns Token[] | nothing {
    var tokens :: Token[]

    each token in input {
        if token == "+" or token == "-" or token == "*" or token == "/" then {
            @push(tokens, Token {
                token_type is .OPERATOR,
                value is token,
            })
        }
        else if token == "(" then {
            @push(tokens, Token {
                token_type is .LPAREN,
                value is token,
            })
        }
        else if token == ")" then {
            @push(tokens, Token {
                token_type is .RPAREN,
                value is token,
            })
        } else {
            @push(tokens, Token {
                token_type is .NUMBER,
                value is token,
            })
        }
    }
    return tokens
}