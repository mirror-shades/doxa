enum TokenType {
    NUMBER,
    OPERATOR,
}

struct Token {
    token_type :: TokenType,
    value :: string,
}

// Simple test: 5 + 6 * 3
const simple_eq :: Token[] is [
    Token { 
        token_type is TokenType.NUMBER,
        value is "5",
     },
    Token { 
        token_type is TokenType.OPERATOR,
        value is "+",
     },
    Token { 
        token_type is TokenType.NUMBER,
        value is "6",
     },
    Token { 
        token_type is TokenType.OPERATOR,
        value is "*",
     },
    Token { 
        token_type is TokenType.NUMBER,
        value is "3",
     },
]

("Input tokens: ")?
simple_eq??
("\nProcessing...\n")?
shunt(simple_eq)??

function shunt(tokens :: Token[]) returns Token[] {
    var output :: Token[]
    var operators :: Token[]
    
    each t in tokens {
        ("Processing token: " + t.value + "\n")?
        
        if t.token_type == TokenType.NUMBER then {
            ("  -> Adding number to output\n")?
            @push(output, t)
        }
        else if t.token_type == TokenType.OPERATOR then {
            const current_prec is precedence(t.value)
            ("  -> Operator precedence: " + @string(current_prec) + "\n")?

            // handle precedence popping
            while @length(operators) > 0 {
                const top_op is operators[@length(operators) - 1]
                ("  -> Checking top operator: " + top_op.value)?
                
                if top_op.token_type != TokenType.OPERATOR then {
                    (" (not operator, breaking)\n")?
                    break
                }

                const top_prec is precedence(top_op.value)
                ("  -> Top precedence: " + @string(top_prec))?
                
                if (top_prec > current_prec) or (top_prec == current_prec and top_op.value != "^") then {
                    (" -> Popping!\n")?
                    const popped is @pop(operators)
                    @push(output, popped)
                } else {
                    (" -> Not popping\n")?
                    break
                }
            }
            
            ("  -> Pushing current operator to stack\n")?
            @push(operators, t)
        }
        
        ("  Output so far: ")?
        output??
        ("  Operator stack: ")?
        operators??
        ("\n")?
    }
    
    // flush any remaining operators
    ("Flushing remaining operators...\n")?
    while @length(operators) > 0 {
        const popped is @pop(operators)
        @push(output, popped)
    }
    
    return output
}

function precedence(op :: string) returns int {
    const result is match op {
        "+" then 1,
        "-" then 1,
        "*" then 2,
        "/" then 2,
        "^" then 3,
        else -1,
    }
    return result
} 