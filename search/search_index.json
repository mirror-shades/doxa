{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Doxa","text":"<pre><code>Neither from itself nor from another,\n\nNor from both,\n\nNor without a cause,\n\nDoes anything whatever, anywhere arise.\n\n- N\u0101g\u0101rjuna\n    Verses on the Middle Way (2nd\u20133rd century CE)\n</code></pre> <p>Doxa is a simple to write, highly readible language based on four corned logic inspired by the logic of Nagarjuna. In Doxa there are no booleans. Doxa instead uses a four cournered logical unit called a tetra. Tetras can represent true and false, which act as you would expect them to in a traditional programing language.</p>"},{"location":"syntax/","title":"Doxa Language Reference","text":""},{"location":"syntax/#core-language-features","title":"Core Language Features","text":""},{"location":"syntax/#type-system","title":"Type System","text":"<ul> <li>No operator or function overloading</li> <li>No classes, only structs and composition</li> <li>Garbage collected memory management</li> </ul>"},{"location":"syntax/#basic-composition-example","title":"Basic Composition Example","text":"<pre><code>struct Animal {\n    name: string\n}\n\nstruct Dog {\n    // Composition instead of inheritance\n    animal: Animal,\n    breed: string,\n\n    fn bark(self) {\n        print(animal.name + \" says woof!\");\n    }\n}\n\nvar dog is Dog {\n    animal: Animal {\n        name: \"Spot\"\n        },\n    breed: \"Labrador\"\n};\n</code></pre> <p>&lt;!-- ### Modules</p> <pre><code>// math.doxa\n#safe\nexport fn add(a :: int, b :: int) -&gt; int {\n    return a + b;\n}\n\n// main.doxa\nimport { add } from \"./math.doxa\";\nvar sum is add(1, 2);\n``` --&gt;\n\n## Data Types\n\n### Basic Types\n\nStandard types include:\n\n- `int`: Integer numbers\n- `float`: Floating point numbers\n- `string`: Text strings\n- `tetra`: Four-valued logic system\n\nThe `tetra` type represents a four cornered value with the possible states: `true`, `false`, `both`, and `neither`. For additional information see the tetra page.\n\n````\n\n### Arrays\n\nArrays are homogeneous collections with type inference:\n\n```doxa\nvar nums :: int[] is [1, 2, 3];    // Explicit typing\nvar strs is [\"a\", \"b\"];            // Inferred as string[]\n\n// Invalid operations\nvar mixed is [1, \"two\", true];     // Error: mixed types\nnums.push(\"four\");                // Error: type mismatch\n````\n\n### Tuples\n\nFixed-size collections supporting heterogenus types:\n\n```doxa\nvar point is (: 10, \"hello\", true :);         // Simple tuple\nvar nested is (: (: 1, \"hello\" :), (: 3, true :) :);    // Nested tuple\n\npoint[0];                         // Access first element\nnested[1][0];                     // Access nested element\n</code></pre>"},{"location":"syntax/#maps","title":"Maps","text":"<p>String-keyed dictionaries:</p> <pre><code>var scores is {\n    \"alice\": 100,\n    \"bob\": 85\n};\nscores[\"alice\"];                  // Access value\n</code></pre>"},{"location":"syntax/#control-flow","title":"Control Flow","text":""},{"location":"syntax/#pattern-matching","title":"Pattern Matching","text":"<pre><code>enum Status { Success, Error, Pending }\n\nvar result is match status {\n    .Success =&gt; \"all good\",\n    .Error =&gt; \"failed\",\n    else =&gt; \"waiting\"\n};\n</code></pre> <p>Warning</p> <p>Match expressions must be exhaustive or include an <code>else</code> clause.</p>"},{"location":"syntax/#error-handling","title":"Error Handling","text":"<pre><code>try {\n    riskyOperation();\n} catch {\n    handleError();\n}\n</code></pre>"},{"location":"syntax/#special-operators","title":"Special Operators","text":""},{"location":"syntax/#inspect","title":"Inspect (<code>?</code>)","text":"<pre><code>var x is computeValue();\nx?;                              // Prints value with location\n</code></pre>"},{"location":"syntax/#type-information","title":"Type Information","text":"<pre><code>typeof(42);                      // \"int\"\ntypeof(\"hello\");                 // \"string\"\ntypeof([1,2,3]);                 // \"array\"\n</code></pre>"},{"location":"syntax/#collection-quantifiers","title":"Collection Quantifiers","text":"<pre><code>(\u2203x \u2208 numbers : x &gt; 10) // Logical notation\n(exists x in numbers where x &gt; 10) // English prose\n(\u2200x \u2208 numbers : x &gt; 0) // Logical notation\n(forall x in numbers where x &gt; 0) // English prose\n</code></pre>"},{"location":"syntax/#conditional-expressions","title":"Conditional Expressions","text":"<p>All conditionals are expressions and return values:</p> <pre><code>var result is if condition then {\n    value1\n} else {\n    value2\n};\n</code></pre> <p>Note</p> <p>Expressions without a value return <code>nothing</code>: <code>doxa     var x is if (false) { y is 1 };  // x becomes nothing</code></p>"},{"location":"syntax/#function-return-types","title":"Function Return Types","text":"<p>Functions can specify return types using either <code>-&gt;</code> or <code>returns</code> syntax:</p> <pre><code>fn add(a: int, b: int) -&gt; int {\n    return a + b;\n}\n\n// Alternative syntax\nfn add(a: int, b: int) returns(int) {\n    return a + b;\n}\n</code></pre> <p>return types are optional and inferred by default:</p> <pre><code>// Normal Mode - Valid\nfn add(a, b) {\n    return a + b;\n}\n</code></pre>"},{"location":"syntax/#logical-operators","title":"Logical Operators","text":""},{"location":"syntax/#first-order-logic-notation","title":"First-Order Logic Notation","text":"<p>Doxa supports traditional first-order logic notation alongside English keywords:</p> Symbol Keyword Description <code>\u2203</code> exists At least one element satisfies condition <code>\u2200</code> forall All elements satisfy condition <code>\u00ac</code> not Logical negation <code>\u2227</code> and Logical AND <code>\u2228</code> or Logical OR <code>\u2194</code> iff Logical equivalence (if and only if) <code>\u2295</code> xor Exclusive OR <code>\u2191</code> nand Not AND <code>\u2193</code> nor Not OR <code>\u2192</code> implies Logical implication <p>Examples:</p> <pre><code>const arr :: int[] is [1, 2, 3, 4, 5];\n// Quantifiers\n(\u2203x \u2208 arr : x &gt; 3)?;     // true\n(\u2200x \u2208 arr : x &gt; 3)?;     // false\n(\u00ac\u2200x \u2208 arr : x &gt; 3)?;    // true\n\n// Logical operations\n(false \u2194 false)?;        // true (equivalent)\n(true \u2295 true)?;         // false (XOR)\n(true \u2227 false)?;        // false\n(true \u2228 false)?;        // true\n(true \u2192 false)?;        // false\n</code></pre>"},{"location":"syntax/#modes-of-operation-not-yet-implemented","title":"Modes of Operation (not yet implemented)","text":"<p>Doxa supports three operational modes:</p> <ul> <li>Normal Mode (default): Dynamic typing with flexible syntax</li> <li>Safe Mode: Enabled via <code>#safe</code> at file start, enforces static typing</li> <li>Warn Mode: Compiles in normal mode but warns about safe convention violations</li> </ul> <p>Note</p> <p>Safe files can only import other safe files, while normal files can import both.</p>"},{"location":"tetras/","title":"Doxa Language Reference","text":""},{"location":"tetras/#tetras","title":"Tetras","text":""},{"location":"tetras/#type-overview","title":"Type overview","text":"<p>A tetra is a type which represents four cornered logic. You can think of a tetra like an extended boolean type which would represent two cornered logic. The four states which tetras can exist in are:</p> <p><code>true</code> - These first two values should be familiar <code>false</code> <code>both</code> - This is equivilant to both true and false <code>neither</code> - This is equivilatnt neither to true or false</p>"},{"location":"tetras/#first-order-logic","title":"First order logic","text":"<p>Doxa has extensive for traditional first order logics that work as expected with true and false values. These can be represented in formal unicode notation:</p> <pre><code>const arr :: int[] = [1, 2, 3, 4, 5]\n\n// existential quantifier \u2203, element of \u2208\n\u2203x \u2208 arr : x &gt; 3; // true\n\n// universal quantifier \u2200, where :\n\u2200x \u2208 arr : x &gt; 3; // false\n\n// NOT \u00ac\n\u00acfalse; // true\n\n// biconditional \u2194\nfalse \u2194 false; // true\n\n// XOR \u2295\ntrue \u2295 true; // false\n\n// AND \u2227\ntrue \u2227 false; // false\n\n// OR \u2228\ntrue \u2228 false; // true\n\n// NAND \u2191\ntrue \u2191 false; // true\n\n// NOR \u2193\ntrue \u2193 false; // false\n\n// implication \u2192\ntrue \u2192 false; // false\n</code></pre> <p>This unicode support is paired with plaintext keywords which act in an identical fashion:</p> <pre><code>\u2203 - exists\n\u2200 - forall\n\u2208 - in\n: - where\n\u00ac - not\n\u2194 - iff\n\u2295 - xor\n\u2227 - and\n\u2228 - or\n\u2191 - nand\n\u2193 - nor\n\u2192 - implies\n</code></pre> <p>This means formal logical representation can be written in either way:</p> <pre><code>const arr :: int[] = [1, 2, 3, 4, 5]\n\n\u00ac(\u2200x \u2208 arr : x &gt; 3); // true\nnot (forall x in arr where x &gt; 3); // true\n</code></pre>"}]}