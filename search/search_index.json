{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Doxa","text":"<pre><code>Everything is real and is not real,\nBoth real and not real,\nNeither real nor not real.\nThis is Lord Buddha\u2019s teaching.\n\n- N\u0101g\u0101rjuna\n    Verses on the Middle Way (2nd\u20133rd century CE)\n</code></pre> <p>Doxa is a simple to write, highly readible language based on four corned logical values inspired by the logic of Nagarjuna. In Doxa there are no booleans. Doxa instead uses a four cournered logical unit called a tetra. Tetras can represent true and false, which act as you would expect them to in a traditional programing language.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Language Syntax - Complete language reference</li> <li>Tetras - Four-cornered logic system</li> <li>SOXA Format - Binary intermediate representation and execution format</li> </ul>"},{"location":"alias/","title":"Alias","text":"<p>Alias Parameters (^)</p> <p>Overview Alias parameters allow a function to modify a caller\u2019s variable directly, without general-purpose pointers or references. They are opt-in at both the function signature and call site, making mutations explicit and safe. Aliases are stack-bound, cannot escape their defining function, and cannot be taken from partial subfields or array elements.</p> <p>Syntax</p> <p>fn modify(^param :: int) { param += 1 // Directly mutates caller's variable }</p> <p>var x = 0 modify(^x) // Caller opts-in to mutation // x == 1</p> <p>Core Rules</p> <pre><code>Parameter-only \u2014 ^T may only appear in function parameters, never in locals, returns, or stored types.\n\nLvalue-only \u2014 Only full variables can be aliased no temporaries, expressions, struct fields, or array elements.\n\nExplicit call-site \u2014 Caller must pass ^var to grant mutation rights.\n\nNo alias duplication \u2014 The same variable cannot be passed to more than one alias parameter in the same call.\n\nNo alias + by-value mix \u2014 A variable cannot be passed aliased and by-value in the same call.\n\nNo escaping \u2014 Aliases cannot be returned, stored, or captured by closures.\n\nNo address-of \u2014 Taking &amp; of an alias parameter is forbidden.\n\nNo async/threads \u2014 Aliases are banned in async functions and cannot be passed to concurrent tasks.\n\nExclusive borrow \u2014 Aliases grant exclusive mutable access for the duration of the call no overlapping borrows allowed.\n\nFFI control \u2014 Passing aliases to foreign code requires explicit unsafe or noescape annotation.\n\nEvaluation order \u2014 Arguments evaluate left-to-right, but banned alias patterns remain errors.\n</code></pre> <p>Example: Safe Swap</p> <p>fn swap(^a :: int, ^b :: int) { let tmp is a a is b b is tmp }</p> <p>var x is 1, y is 2 swap(^x, ^y) // x == 2, y == 1</p> <p>Example: Compile-time Error Cases</p> <p>swap(^x, ^x) // \u274c same variable passed twice modify(^(x + 1)) // \u274c temporaries not allowed f(^obj.field) // \u274c partial object aliasing not allowed g(^x, x) // \u274c aliased and by-value in same call</p> <p>Design Intent This model offers mutation semantics without full pointers, preserving deterministic lifetime and memory safety under stack-based allocation. By forcing explicit syntax and disallowing escaping or partial aliasing, it avoids common pitfalls of traditional references while retaining enough flexibility for in-place updates.</p>"},{"location":"bytecode/","title":"Bytecode lowering (draft)","text":"<p>The bytecode layer sits between Soxa HIR and the runtime. Use <code>BytecodeGenerator</code> to translate a <code>HIRProgram</code> into a <code>BytecodeModule</code> that records canonical opcodes, preserved metadata, and function bounds.</p> <pre><code>const bc = @import(\"../src/codegen/bytecode/generator.zig\");\nconst writer = @import(\"../src/codegen/bytecode/writer.zig\");\n\nvar generator = bc.BytecodeGenerator.init(allocator, \"out\", \"test\");\nvar module = try generator.generate(hir_program);\ndefer module.deinit();\n\nif (module.artifact_path) |path| {\n    try writer.writeBytecodeModuleToFile(&amp;module, path);\n}\n</code></pre> <p>Key points: - The generator mirrors the current HIR instruction set while   normalising operands (variable slots, type tags, label ids). - Jump targets are resolved to stable label ids; actual instruction   offsets can be computed when the VM loads the module. - <code>BytecodeModule</code> borrows the HIR constant and string pools\u2014keep the   HIR program alive while the bytecode module is in use. - Function metadata (<code>start_ip</code>, <code>body_ip</code>, aliases, parameter types)   is carried over so the VM can size frames without re-walking HIR.</p> <p>This implementation intentionally returns <code>UnsupportedHIRInstruction</code> for opcodes that are not yet lowered. Add handling in <code>Context.lowerInstruction</code> as new VM features land.</p>"},{"location":"control/","title":"Control","text":""},{"location":"control/#control-flow","title":"Control Flow","text":"<p>Doxa unifies conditional branching with a consistent then / else pattern across if, as, and match.</p>"},{"location":"control/#if-then-else","title":"if / then / else","text":"<ul> <li>then required, else optional.</li> </ul> <p>Examples:</p> <pre><code>if x &gt; 10 then {\n    @print(\"x is greater than 10/n\")\n} else {\n    @print(\"x is 10 or less/n\")\n}\n\nvar condition is if true then \"true\" else \"false\"\n</code></pre> <p>Chaining and statement-style:</p> <pre><code>if current % 3 equals 0 and current % 5 equals 0 then @print(\"fizzbuzz/n\")\nelse if current % 3 equals 0 then @print(\"fizz/n\")\nelse if current % 5 equals 0 then @print(\"buzz/n\")\nelse @print(current)\n</code></pre>"},{"location":"control/#as-then-else-type-narrowing","title":"as / then / else (type narrowing)","text":"<ul> <li>else required, then optional.</li> <li>Same body rules: expression bodies end with , block bodies do not.</li> </ul> <p>Examples:</p> <pre><code>// Success and failure as expressions\nconst n_or_zero is value as int else 0\n\n// Block failure case\nvalue as int else {\n    @print(\"value is not an int/n\")\n}\n\n// Explicit success block\nvalue as int then {\n    // use the narrowed int value here\n} else {\n    // handle non-int here\n}\n</code></pre>"},{"location":"control/#if-vs-as","title":"if vs as","text":"<p>In Doxa, if and as both use the then / else pattern, but they invert the emphasis:</p> Keyword Requires Optional Implied meaning if then else If success then do x, failure branch optional as else then As a type or else do x, success branch optional <p><code>if</code> is a keyword which implicitly requires a success condition, <code>as</code> implicity requires a fail condition, but both use then/else blocks in the same way.</p> <p>Examples</p> <pre><code>// IF: Truth-driven\nif x &gt; 10 then @print(\"big/n\") else @print(\"small/n\")\n\n// AS: Fallback-driven\nvalue as int else 0         // If not int, use 0\nvalue as int then 20 else 0  // If int, use 20  else 0\n\n// Both in action\nif isReady then start() else wait()\ndata as string then parse(data) else log(\"Bad data/n\")\n</code></pre>"},{"location":"control/#match-values-and-union-types","title":"match (values and union types)","text":"<p>Use match to branch on:</p> <ul> <li>Concrete values: numbers, strings, enum variants (<code>.Red</code>, <code>.Green</code>, ...)</li> <li>Union type arms: <code>int</code>, <code>float</code>, <code>string</code>, <code>byte</code>, <code>tetra</code>, <code>nothing</code>, or custom types</li> </ul> <p>Arm syntax and delimiters:</p> <ul> <li>Pattern arms: <code>pattern then BODY</code></li> <li>Else arm: <code>else BODY</code> (no then)</li> <li>Body: expression (end with <code></code>) or block <code>{ ... }</code> (no trailing <code></code>)</li> </ul> <p>Match on union types:</p> <pre><code>fn kind(value :: int | float) returns(string) {\n    return match value {\n        int then @print(\"integer/n\")\n        float then @print(\"float/n\")\n    }\n}\n</code></pre> <p>Match on enums and values:</p> <pre><code>enum Color { Red, Green, Blue }\n\nvar msg1 is match color {\n    .Red then \"It's red\"\n    .Blue then \"It's blue\"\n    else \"It's something else\"\n}\n\nconst x is 5\nvar msg2 is match x {\n    0 then \"It's zero\"\n    5 then \"It's five\"\n    else \"It's something else\"\n}\n\nconst s is \"big\"\nvar msg3 is match s {\n    \"big\" then \"It's big\"\n    \"small\" then \"It's small\"\n    else \"It's something else\"\n}\n</code></pre> <p>Block arms in match:</p> <pre><code>var msg is match color {\n    // semicolons can be used to represent line breaks\n    .Red then { @print(\"stop/n\"); \"red\"}\n    .Green then { @print(\"go/n\"); \"green\"\n    else { @print(\"caution/n\"); \"yellowish\"}\n}\n</code></pre> <p>Notes:</p> <ul> <li>Exhaustiveness: For enums, prefer covering all variants or add an <code>else</code> arm. For unions, cover the needed type arms <code>else</code> is optional.</li> <li>Result type: All arms must produce a compatible result type. For block arms, the last expression is the arm\u2019s value.</li> </ul>"},{"location":"control/#quick-reference","title":"Quick reference","text":"<ul> <li>if: then required else optional expression body ends with , block body does not.</li> <li>as: else required then optional same body rules.</li> <li>match: pattern then BODY else BODY arm separation via expression  or closing block <code>}</code>.</li> </ul>"},{"location":"inline/","title":"Inline","text":"<p><code>zig</code> inline blocks should be limited in the following ways.  1) they can only define functions, no global state (other than imports?) 2) they must have valid doxa types (i64, f64, u8, []const u8, boolean, void) for all parameters and its return value</p> <pre><code>zig ZigOps {\n    fn fast_hash(data: []const u8) -&gt; u64 {\n        return @llvm_external_call(\"ZigOps.fast_hash\", data.ptr, data.len);\n    }\n\n    fn sqrt_approx(x: f64) -&gt; f64 {\n        return @llvm_external_call(\"ZigOps.sqrt_approx\", x);\n    }\n}\n\nconst zigSqrt is ZigOps.sqrt_approx(10.5)\n</code></pre> <p>within the  is compiled to .o and caches after HIR gen and before the pipeline splits. the object is linked in compilation or accessed jit in vm execution</p> <p>with some clairity on rules, molecular types could be provided as well. structs would need to have a matching zig counterpart, and arrays would need to be handled as slices, etc. This can come later.</p>"},{"location":"loops/","title":"Loops","text":"<p>Doxa takes a unique approach to loops. The best way to think about it is that the loop syntax is fully composible. The structure of the full loop will be similar to anyone familiar to C style loops:</p> <pre><code>// doxa\nfor x while x &lt; 10 do x += 1 {\n  ...\n}\n// c\nfor(int x, x &lt; 10; x++) {\n\n}\n</code></pre> <p>Each section of the above the for loop works the same, the key difference being each section is marked by its own keyword. This main advantage this provides is that each section of the for loop becomes decomposable. Doxa allows you to use any combination of loop constructs to add functionality to the loop as needed. Regardless of which construct you use, it will always follow the syntactical precedent of C loops: for -&gt; while -&gt; do.</p>"},{"location":"loops/#core-loop-constructs","title":"Core Loop Constructs","text":""},{"location":"loops/#for-loops","title":"For Loops","text":"<p>Purpose: Loop which has a scope-level int which persists between loops. The variable is always an int will be defaulted to 0 if not initialized.</p> <pre><code>for hand {\n  hand += draw_card();\n  if hand &gt; 21 then bust();\n  else if hand &gt; 17 then hold();\n  else hit();\n}\n</code></pre>"},{"location":"loops/#while-loops","title":"While Loops","text":"<p>Purpose: Condition-based loop that executes while a condition is true.</p> <pre><code>while &lt;condition&gt; { ... }\n</code></pre> <p>Examples:</p> <pre><code>// With early exit\nwhile has_next() {\n  const item is next()\n  if item == 0 then break\n}\n</code></pre>"},{"location":"loops/#do-loops","title":"Do Loops","text":"<p>Purpose: Step-focused loop that executes a step following each iteration. Following C traditions, steps always execute after each iteration of the loop body, before the next condition check.</p> <pre><code>do &lt;step&gt; { ... }\n</code></pre> <p>Examples:</p> <pre><code>// Basic do loop\nconst the_time is getTheTime()\ndo the_time is getTheTime() {\n  if the_time &gt; expiration_time then break\n}\n\n// complex do block\ndo {\n  if getTheTime() &gt; the_time + 100 then {\n    the_time = getTheTime()\n  } else log_too_early()\n} {\n\n  if the_time &gt; expiration_time then {\n    break\n  } else {\n    log_loop()\n  }\n}\n</code></pre>"},{"location":"loops/#infinite-loops","title":"Infinite Loops","text":"<p>You can use <code>while true</code> or just <code>do</code> for infinite loops:</p> <pre><code>while true { ... }  // Traditional infinite loop\ndo { ... }          // Cleaner do-based infinite loop\n</code></pre>"},{"location":"loops/#loop-combinations","title":"Loop Combinations","text":""},{"location":"loops/#while-do-loop","title":"While Do Loop","text":"<pre><code>// Countdown from 10 to 1, then liftoff\nvar countdown is 10\nwhile countdown &gt; 0 do {\n    countdown -= 1\n} {\n    \"T-minus \" + countdown + \" seconds\"?\n}\n\"Liftoff!\"?\n</code></pre>"},{"location":"loops/#for-do-loop","title":"For Do Loop","text":"<pre><code>var sensor_reading is 0\nfor reading do reading = get_reading() {\n    if reading &gt; 7 then {\n        @print(\"Warning: reading is too high!\")\n        break\n    }\n}\n</code></pre>"},{"location":"loops/#for-while-do-loop","title":"For While Do Loop","text":"<pre><code>// Default initialization: process tasks until done\nvar tasks = [\"Write report\", \"Submit assignment\", \"Attend meeting\"]\nvar index is 0  // we start at index 0\nfor index while index &lt; tasks.length do index += 1 {\n    \"Task: \" + tasks[index]?\n}\n\n// Explicit initialization with complex do block\nfor i is 0 while i &lt; @length(tasks) do {\n    // Update: move to next task and log progress\n    i += 1\n    @print(\"Progress: {i} / {@length(tasks)}\\n\")\n} {\n    @print(\"Now doing: tasks[i]\\n\")\n}\n</code></pre>"},{"location":"loops/#loop-table","title":"Loop Table","text":"<p>Here are all the possible combinations for loops using these constructs. Notice that regardless of which constructs you choose, they will be ordered for -&gt; while -&gt; do.</p> <p>Loops with an int exposed: <code>for x</code></p> <p>Loops while a given condition met <code>while y</code></p> <p>Loops using a given step <code>do z</code></p> <p>Loops while a given condition met using a given step <code>while y do z</code></p> <p>Loops with an index using a given step <code>for x do z</code></p> <p>Loops with an int exposed while a given condition met using a given step <code>for x while y do z</code></p>"},{"location":"loops/#collection-iteration","title":"Collection Iteration","text":""},{"location":"loops/#each-loops","title":"Each Loops","text":"<p><code>each</code> provides syntactic sugar for iterating over collections:</p> <pre><code>each item in collection { ... }\neach item at index in collection { ... }\n</code></pre> <p>Expands to:</p> <pre><code>for i while i &lt; @length(collection) do i++ {\n  item is collection[i]\n  // or with index:\n  const index is i\n  ...\n}\n</code></pre> <p>Each Loop Notes:</p> <ul> <li>The <code>at</code> variable provides an immutable copy of the current index</li> <li>Nested loops create independent index copies</li> <li>Modifying the collection during iteration may cause undefined behavior</li> </ul>"},{"location":"loops/#control-flow","title":"Control Flow","text":"<p>All loops support:</p> <ul> <li><code>break</code>: Exit the loop immediately</li> <li><code>continue</code>: Skip to next iteration</li> </ul> <p>Continues will run any given <code>do</code> step before skipping to the next iteration of the loop.</p>"},{"location":"maps/","title":"Maps","text":""},{"location":"maps/#simple-mapping-immutable","title":"Simple Mapping (Immutable)","text":"<p>Maps can store key-value pairs. By default, using const makes the map immutable.</p> <pre><code>const map Entries {\n    1 is \"wow\",\n    2 is \"cool\",\n}\n</code></pre>"},{"location":"maps/#mutable-maps","title":"Mutable Maps","text":"<p>Using var allows the map data to be updated.</p> <pre><code>var map Dict {\n    1 is \"first\"\n    2 is \"third\"\n}\n\nDict[2] is \"second\"\n</code></pre>"},{"location":"maps/#explicit-typing-optional","title":"Explicit Typing (Optional)","text":"<p>If types cannot be inferred from the first entry or for empty maps, explicit key and/or value types are required. The syntax mirrors function declarations:</p> <pre><code>const map PlayerToData :: Player returns Data {\n    .Main is mainData\n}\n</code></pre>"},{"location":"maps/#union-returns","title":"Union Returns","text":"<p>Return types can be return unions for more flexibility on value storage.</p> <pre><code>var map CarSeats returns string | nothing {\n    1 is \"Bob\",\n    2 is nothing,\n    3 is \"Sam\"\n    4 is nothing\n}\n</code></pre>"},{"location":"maps/#accessing-maps","title":"Accessing Maps","text":"<pre><code>var entry is MyMap[\"troll\"]\nvar entry is MyMap[.Troll]\n\n// if mutable\nMyMap[\"troll\"].hp is 100\n</code></pre>"},{"location":"maps/#notes-on-inference","title":"Notes on Inference","text":"<p>Key type is inferred from the first entry if not explicitly declared.</p> <p>Value type is encouraged to be explicit (returns ). <p>Empty maps cannot be inferred and must have both key and value types declared.</p>"},{"location":"methods/","title":"Built-in Methods","text":"<p>Doxa provides built-in methods prefixed with <code>@</code> for core operations.</p>"},{"location":"methods/#methods-that-should-panic-or-halt-on-failure","title":"Methods That Should Panic or Halt on Failure","text":"Method Return Panics On PUSH nothing Array/string corruption if fails POP any Underflow if empty INSERT nothing Array/string corruption if fails REMOVE any Out of bounds index ASSERT nothing False condition PANIC never Always halts EXIT never Always terminates"},{"location":"methods/#methods-that-should-return-error-unions","title":"Methods That Should Return Error Unions","text":"Method Return READ string | IOError - file contents or error WRITE nothing | IOError - writes to file or error INPUT string | IOError - line from stdin or EOF error TOINT int | ParseError - parsed integer or parse error TOFLOAT float | ParseError - parsed float or parse error TOBYTE byte | ParseError - byte representation or conversion error SLICE array | IndexError or string | IndexError - based on input type SLEEP nothing | SysError - sleeps or interruption error PRINT nothing | IOError - prints to stdout or I/O error SPAWN int | SysError - PID of spawned process or error KILL nothing | SysError - kills process or error WAIT int | Nothing | SysError - exit code or error"},{"location":"methods/#no-failure","title":"No Failure","text":"Method Return TOSTRING string TYPE int LENGTH int OS string ARCH string ABI string TIME int RANDOM float ALIVE tetra"},{"location":"methods/#array-methods","title":"Array Methods","text":""},{"location":"methods/#length","title":"@length","text":"<ul> <li>Input: <code>string | array</code></li> <li>Output: <code>int</code> - length of input</li> <li>Example: <code>@length(\"hello\")</code> \u2192 <code>5</code></li> </ul>"},{"location":"methods/#push","title":"@push","text":"<ul> <li>Input: <code>array | string</code>, <code>value</code></li> <li>Output: <code>nothing</code> - modifies array/string in place by adding value to end</li> <li>Example: <code>@push(arr, 3)</code> // adds 3 to arr, returns nothing</li> </ul>"},{"location":"methods/#pop","title":"@pop","text":"<ul> <li>Input: <code>array | string</code></li> <li>Output: <code>any</code> - removes and returns last element</li> <li>Example: <code>var last = @pop(arr)</code></li> </ul>"},{"location":"methods/#insert","title":"@insert","text":"<ul> <li>Input: <code>array | string</code>, <code>index</code>, <code>value</code></li> <li>Output: <code>nothing</code> - inserts value at index</li> <li>Example: <code>@insert(arr, 1, 5)</code> // inserts 5 at index 1</li> </ul>"},{"location":"methods/#remove","title":"@remove","text":"<ul> <li>Input: <code>array | string</code>, <code>index</code></li> <li>Output: <code>any</code> - removes and returns element at index</li> <li>Example: <code>var removed = @remove(arr, 1)</code></li> </ul>"},{"location":"methods/#clear","title":"@clear","text":"<ul> <li>Input: <code>array | string</code></li> <li>Output: <code>nothing</code> - removes all elements</li> <li>Example: <code>@clear(arr)</code> // arr becomes []</li> </ul>"},{"location":"methods/#find","title":"@find","text":"<ul> <li>Input: <code>array | string</code>, <code>value</code></li> <li>Output: <code>int</code> - index of first occurrence, -1 if not found</li> <li>Example: <code>@find([1,2,3], 2)</code> \u2192 <code>1</code></li> </ul>"},{"location":"methods/#slice","title":"@slice","text":"<ul> <li>Input: <code>string | array</code>, <code>int</code> (start), <code>int</code> (length)</li> <li>Output: <code>string OR array | ValueError</code> - substring/subarray</li> <li>Example: <code>@slice(\"hello\", 1, 3)</code> \u2192 <code>\"ell\"</code></li> </ul>"},{"location":"methods/#copy","title":"@copy","text":"<ul> <li>Input: <code>array | string | map</code></li> <li>Output: <code>same type</code> - shallow copy</li> <li>Example: <code>var copy = @copy(original)</code></li> </ul>"},{"location":"methods/#type-methods","title":"Type Methods","text":""},{"location":"methods/#string","title":"@string","text":"<ul> <li>Input: <code>any</code></li> <li>Output: <code>string</code> - string representation</li> <li>Example: <code>@string(123)</code> \u2192 <code>\"123\"</code></li> </ul>"},{"location":"methods/#int","title":"@int","text":"<ul> <li>Input: <code>float | byte | string</code></li> <li>Output: <code>int | ValueError</code> - parsed integer</li> <li>Example: <code>@int(\"123\")</code> \u2192 <code>123</code></li> </ul>"},{"location":"methods/#float","title":"@float","text":"<ul> <li>Input: <code>int | byte | string</code></li> <li>Output: <code>float | ValueError</code> - parsed float</li> <li>Example: <code>@float(\"123.45\")</code> \u2192 <code>123.45</code></li> </ul>"},{"location":"methods/#byte","title":"@byte","text":"<ul> <li>Input: <code>int | float | string</code></li> <li>Output: <code>byte | ValueError</code> - byte representation</li> <li>Example: <code>@byte(10)</code> \u2192 <code>0x0A</code></li> </ul>"},{"location":"methods/#type","title":"@type","text":"<ul> <li>Input: <code>any</code></li> <li>Output: <code>string</code> - type name</li> <li>Example: <code>@type([1,2])</code> \u2192 <code>\"array\"</code></li> </ul>"},{"location":"methods/#time","title":"@time","text":"<ul> <li>Input: <code>none</code></li> <li>Output: <code>int</code> - current timestamp, -1 sentinel on rare runtime error</li> <li>Example: <code>var now = @time()</code></li> </ul>"},{"location":"methods/#random","title":"@random","text":"<ul> <li>Input: <code>none</code></li> <li>Output: <code>int</code> - random number, compile-time error if not supported</li> <li>Example: <code>var num = @random()</code></li> </ul>"},{"location":"methods/#process-methods","title":"Process Methods","text":""},{"location":"methods/#spawn","title":"@spawn","text":"<ul> <li>Input: <code>string[]</code> (command and arguments)</li> <li>Output: <code>int | SysError</code> - PID of spawned process, or error</li> <li>Example: <code>var pid = @spawn([\"my_program\", \"arg1\"])</code></li> </ul>"},{"location":"methods/#kill","title":"@kill","text":"<ul> <li>Input: <code>int</code> (PID)</li> <li>Output: <code>nothing | SysError</code> - kills process, or error</li> <li>Example: <code>@kill(pid)</code></li> </ul>"},{"location":"methods/#wait","title":"@wait","text":"<ul> <li>Input: <code>int</code> (PID)</li> <li>Output: <code>int | Nothing | WaitError</code> - exit code, or error</li> <li>Example: <code>var exitCode = @wait(pid)</code></li> </ul>"},{"location":"methods/#alive","title":"@alive","text":"<ul> <li>Input: <code>int</code> (PID)</li> <li>Output: `</li> </ul> <pre><code>enum ParseError {        // type conversion failures\n    InvalidFormat,       // e.g., \"abc\" -&gt; int\n    Overflow,            // too large for target type\n    Underflow,           // too small for target type\n}\n\nenum IndexError {        // array/string/collection bounds issues\n    OutOfBounds,         // index &gt;= length\n    Underflow,           // pop/remove from empty\n    Empty,               // access empty collection\n    InvalidRange         // invalid slice/range\n}\n\nenum IOError {           // filesystem / I/O issues\n    EOF,                 // end-of-file / input exhausted\n    NotFound,            // file missing\n    PermissionDenied,    // insufficient permissions\n    Failed               // read or write failed\n}\n\nenum SysError {          // system call failures\n    NotFound,            // missing process/resource\n    PermissionDenied,    // lack of privileges\n    Timeout,             // operation timed out\n    Failed               // generic system failure\n}\n\n// enum name reserved for future builtins\nenum NetworkError {\n    Unreachable,      // host/server cannot be reached\n    Timeout,          // request timed out\n    PermissionDenied, // lack of privileges to open socket/port\n    Failed            // generic network failure\n}\n</code></pre>"},{"location":"struct/","title":"Structs","text":"<p>Since Doxa has a tightly limited number of types, structs are useful for modeling more complex data. Structs are based off composition to avoid pitfalls inherent to inheretance. Variables, functions, and methods are all private unless marked pub.</p>"},{"location":"struct/#real-world-example","title":"Real world example","text":"<p>struct Point {     x :: int, // unless marked pub, values are private     y :: int,</p> <pre><code>pub id :: int,\n\npub function New(x :: int, y :: int) { // fucntions and methods are private unless marked pub as well\n    return Point {\n        x is x,\n        y is y,\n    }\n}\n\nfunction safeSub(a :: int, b :: int) returns int { // normal functions within structs are static\n    result is a - b\n    if result &gt; 255 or result &lt; 0 then return -1\n    return result\n}\n\npub method get() { // the `method` keyword lets you access \n    return Point {\n        this.x,\n        this.y\n    }\n}\n\npub method getDelta() returns int {\n    return Point.safeSub(this.x, this.y) // static methods can be called within instance methods\n}\n</code></pre> <p>}</p>"},{"location":"struct/#basic-composition-example","title":"Basic Composition Example","text":"<pre><code>struct Animal {\n    name: string\n}\n\nstruct Dog {\n    // Composition instead of inheritance\n    animal: Animal,\n    breed: string,\n\n    fn bark(self) {\n        print(animal.name + \" says woof!\")\n    }\n}\n\nvar dog is Dog {\n    animal: Animal {\n        name: \"Spot\"\n        },\n    breed: \"Labrador\"\n}\n</code></pre>"},{"location":"syntax/","title":"Doxa Language Reference","text":""},{"location":"syntax/#core-language-features","title":"Core Language Features","text":""},{"location":"syntax/#primitive-types","title":"Primitive Types","text":"<p>Doxa has two general catagory of types, atomic and molecular:</p>"},{"location":"syntax/#atomic","title":"Atomic","text":"<p>Atomic types are the most basic units of data. Currently Doxa has 3 default number types. Types listed reflect their Zig equivilent. Bigint may be added in the future for increased flexibility.</p> <p>int - i64 float - f64 byte - u8 hex string - []const u8 tetra - i2 nothing - void</p> <p>The <code>tetra</code> type represents a four cornered value with the possible states: <code>true</code>, <code>false</code>, <code>both</code>, and <code>neither</code>. For additional information see the tetra page.</p>"},{"location":"syntax/#molecular","title":"Molecular","text":"<p>Molecular types are constructed out of atomic types. They are</p> <p>array - must be homogenous struct - no classes, no inheretance, only composition enum union - can be handled with switch statements and type narrowing, see page on unions for more info</p> <pre><code>### Arrays\n\nArrays are homogeneous collections with type inference:\n\n```doxa\nvar nums :: int[] is [1, 2, 3]    // Explicit typing\nvar strs is [\"a\", \"b\"]            // Inferred as string[]\n\n// Invalid operations\nvar mixed is [1, \"two\", true]     // Error: mixed types\n@push(nums, \"four\")                // Error: type mismatch\n</code></pre>"},{"location":"syntax/#maps","title":"Maps","text":"<p>String-keyed dictionaries:</p> <pre><code>map scores {\n    \"alice\" is 100,\n    \"bob\" is 85\n}\nscores[\"alice\"]                  // Access value\n</code></pre>"},{"location":"syntax/#control-flow","title":"Control Flow","text":""},{"location":"syntax/#pattern-matching","title":"Pattern Matching","text":"<pre><code>enum Status { Success, Error, Pending }\n\nvar result is match status {\n    .Success =&gt; \"all good\",\n    .Error =&gt; \"failed\",\n    else =&gt; \"waiting\"\n}\n</code></pre> <p>Match expressions must be exhaustive or include an <code>else</code> clause.</p>"},{"location":"syntax/#error-handling","title":"Error Handling","text":"<p>Errors are best handled with custom enum and type unions.</p> <pre><code>enum Error {\n    TOO_BIG,\n    TOO_SMALL,\n}\n\nconst res is intOrError()\nres as int then {\n    intsOnly(res) // narrowed to int\n} else {\n    match res { // else blocks do not narrow\n        Error.TOO_BIG then {\n            @print(\"result was too big\")\n        }\n        Error.TOO_SMALL then {\n            @print(\"result was too small\")\n        }\n        else { // we know this will never be reached\n            @panic(\"unreachable\")\n        }\n    }\n}\n</code></pre>"},{"location":"syntax/#special-operators","title":"Special Operators","text":""},{"location":"syntax/#peek-operator","title":"Peek operator (<code>?</code>)","text":"<p><pre><code>var x is computeValue()\nx?                              // Prints value with location, name, and type\n</code></pre> <pre><code>[./test.doxa:2:2] x :: int is 62\n</code></pre></p>"},{"location":"syntax/#range-to","title":"Range (<code>to</code>)","text":"<p>Ranges are arrays which can be declared between two ints or bytes</p> <pre><code>const range is 10 to 15\n@print(\"{range}\") // [10, 11, 12, 13, 14, 15]\n</code></pre>"},{"location":"syntax/#collection-quantifiers","title":"Collection Quantifiers","text":"<p>As with all formal logic operations, both symbolic notation and keyword notations are supported.</p> <pre><code>(\u2203x \u2208 numbers : x &gt; 10) // Logical notation\n(exists x in numbers where x &gt; 10) // English prose\n(\u2200x \u2208 numbers : x &gt; 0) // Logical notation\n(forall x in numbers where x &gt; 0) // English prose\n</code></pre>"},{"location":"syntax/#conditional-expressions","title":"Conditional Expressions","text":"<p>All conditionals can be used as expressions to assign values:</p> <pre><code>var result is if condition then {\n    value1\n} else {\n    value2\n}\n</code></pre> <p>Be aware assigning an expression without a value will assign <code>nothing</code>: <pre><code>    var x is if (false) { y is 1 }  // x becomes nothing\n</code></pre></p>"},{"location":"syntax/#function-return-types","title":"Function Return Types","text":"<p>Functions can specify return types using the <code>returns</code> syntax. Any type can be returned, including molecular types, but only one type at a time. This is one of the places where type unions can come in handy.</p> <pre><code>fn add(a: int, b: int) returns int {\n    return a + b\n}\n</code></pre> <p>Return types are optional and inferred by default:</p> <pre><code>fn add(a :: int, b :: int) {\n    return a + b // inferred as returning an int\n}\n</code></pre> <p>Explicit typing is encouraged as unions will be inferred if more than one type is returned.</p>"},{"location":"syntax/#logic","title":"Logic","text":""},{"location":"syntax/#first-order-logic","title":"First order logic","text":"<p>First order logic always produces a true or false value. For more information on tetras see the tetra page.</p> <p>Doxa has extensive for traditional first order logics that work as expected with true and false values. These can be represented in formal unicode notation:</p> <pre><code>const arr :: int[] = [1, 2, 3, 4, 5]\n\n// existential quantifier \u2203, element of \u2208\n\u2203x \u2208 arr : x &gt; 3 // true\n\n// universal quantifier \u2200, where :\n\u2200x \u2208 arr : x &gt; 3 // false\n\n// NOT \u00ac\n\u00acfalse // true\n\n// biconditional \u2194\nfalse \u2194 false // true\n\n// XOR \u2295\ntrue \u2295 true // false\n\n// AND \u2227\ntrue \u2227 false // false\n\n// OR \u2228\ntrue \u2228 false // true\n\n// NAND \u2191\ntrue \u2191 false // true\n\n// NOR \u2193\ntrue \u2193 false // false\n\n// implication \u2192\ntrue \u2192 false // false\n</code></pre> <p>This unicode support is paired with plaintext keywords which act in an identical fashion:</p> <pre><code>\u2203 - exists\n\u2200 - forall\n\u2208 - in\n: - where\n\u00ac - not\n\u2194 - iff\n\u2295 - xor\n\u2227 - and\n\u2228 - or\n\u2191 - nand\n\u2193 - nor\n\u2192 - implies\n</code></pre> <p>This means formal logical representation can be written in either way:</p> <pre><code>const arr :: int[] = [1, 2, 3, 4, 5]\n\n\u00ac(\u2200x \u2208 arr : x &gt; 3) // true\nnot (forall x in arr where x &gt; 3) // true\n</code></pre>"},{"location":"syntax/#paradoxical-logic","title":"Paradoxical logic","text":"<p>There are currently two paradoxical operators, <code>and</code> and <code>not</code>. These can be represented by the following truth tables:</p> ^ T F B N F F B B N T B T B N B B B B N N N N N N ~ F T T F B N N B"},{"location":"tetras/","title":"Doxa Language Reference","text":""},{"location":"tetras/#tetras","title":"Tetras","text":""},{"location":"tetras/#type-overview","title":"Type overview","text":"<p>A tetra is a type which tries to represent four cornered logic rather than traditional binary logic. You can think of a tetra a like an extended boolean type. In its simplest sense, where bools can exist in only two states, true or false, tetras can exist in four:</p> <p><code>true</code> - These first two values should be familiar <code>false</code> <code>both</code> - This is equivalent to both true and false <code>neither</code> - This is equivalent neither to true or false</p>"},{"location":"tetras/#an-example","title":"An Example","text":"<p>Let's start with a condition, in this case, the condition of being alive. In traditional boolean logic there would be only two states for this condition, true or false, alive or dead. But a tetra can represent logical conditions outside of this true/false, alive/dead binary.</p> <p>Here are four values to represent the four possible states or corners of a tetra:</p> <pre><code>const Bob is true\nconst Shakespeare is false\nconst zombie is both\nconst angel is neither\n</code></pre> <p>Now let's create some conditional logic to understand how a tetra works. Here is a function to discover whether something is alive or not. It takes a single tetra for input then decides if something is alive or not based on whether it is true or false. it then compares the two flags, isAlive and isDead  in order to determine the state.</p> <pre><code>function living(alive :: tetra) returns string {\n    var isAlive is false\n    var isDead is false\n\n    if alive then isAlive is true\n    if not alive then isDead is true\n\n    if isAlive and isDead then return \"is alive and dead\"\n    if isAlive then return \"is alive\"\n    if isDead then return \"is dead\"\n    return \"neither alive or dead\"\n}\n</code></pre> <p>You might notice this function could be written without the flags, by comparing the state of the tetra itself. We are using flags here to deconstruct it in a way we might parse this to using traditional boolean logic. Here is an execution of the function:</p> <pre><code>@print(\"Bob {living(Bob)}\\n\")\n@print(\"Shakespeare {living(Shakespeare)}\\n\")\n@print(\"zombie {living(zombie)}\\n\")\n@print(\"angel {living(angel)}\\n\")\n</code></pre> <p>And here is the output I received:</p> <pre><code>Bob is alive\nShakespeare is dead\nzombie is alive and dead\nangel neither alive or dead\n</code></pre> <p>When deconstructed like this we can see the logic is relatively simple. True only triggers conditions which are true. False only triggers conditions which are false. Both will always trigger a condition. Neither will never trigger a condition. </p> <p>A purely functional way to imagine this is that both is a true value which cannot be negated, and neither is a false value which cannot be negated.</p> <p>Keep in mind, a tetra is a value just like a boolean is. A tetra doesn't alter the flow of conditional branches, rather it provides states which trigger conditionals in a paradoxical way.</p> <p>We treat the else clause as exactly what it sounds like: \"if a condition is met, then do x, or else do y\". Since both will always trigger a condition, and neither will never trigger a condition, both will never trigger the else clause, and neither will always trigger the else clause.</p>"},{"location":"tetras/#a-use-case","title":"A use case","text":"<p>Where a tetra really excels is dealing with fuzzy or ambigious data. Take a common example of ambigous data, API calls. Here we are fetching data from an API whose validity we may not be sure of. The call will be stored in a struct which uses a tetra called valid: </p> <p>true mean the data was valid false means the data was invalid both means the data was ambigous, possibly valid, possibly not neither means no data was returned</p> <p>This approach lets us handle ambigous data without using flags or nested if statements:</p> <pre><code>struct Call {\n    data :: string\n    valid :: tetra\n}\n\nconst result :: Call is apiCall()\n\nif not result.valid then log(result) // if the result is not valid or ambigous it is logged \nif result.valid then serveData(result) // if the result is valid or ambigous it is served\n// if no data the conditionals do not trigger and the result falls through\n</code></pre>"},{"location":"tetras/#intentionality","title":"Intentionality","text":"<p>In order to reduce complexity adding contradition into the system must be intentional. There are two ways of adding contradition (both or neither) into the system. First, you can set a tetra manually as both or neither. Second, you can use a special operator called paradoxical and, which will take the input (true and false) as both. Other than this expect a traditional binary result (true or false). All first order logic in doxa necessarily returns a value of true or false.</p>"},{"location":"unions/","title":"Typed Unions","text":""},{"location":"unions/#what-are-unions","title":"What are unions","text":"<p>Unions are a special type which can represent one type or another. For instance, you can make a value that either returns a number, or a string. A union can only hold a single value, and therefore represent a single type when used.</p>"},{"location":"unions/#syntax","title":"Syntax","text":"<p>Unions are declared using pipes:</p> <pre><code>var x :: int | float\nvar y :: string | int | float\n</code></pre> <p>The pipe's only usage in Doxa is to specify a typed union.</p>"},{"location":"unions/#examples","title":"Examples","text":"<pre><code>// A union that can be either an integer or a float\nvar number :: int | float\nnumber is 42     // Valid - integer\nnumber is 3.14   // Valid - float\n\n// A union that can be a string, integer, or float\nvar value :: string | int | float\nvalue is \"hello\" // Valid - string\nvalue is 100     // Valid - integer\nvalue is 2.718   // Valid - float\n\n// Unions default to the first type when not initialized\nvar defaulted :: int | float\ndefaulted?       // Prints 0 (default int value)\n\nvar float_first :: float | int\nfloat_first?     // Prints 0.0 (default float value)\n</code></pre>"},{"location":"unions/#default-behavior","title":"Default Behavior","text":"<p>When a union is declared without initialization, it defaults to the first type in the union with its default value:</p> <ul> <li><code>int</code> defaults to <code>0</code></li> <li><code>float</code> defaults to <code>0.0</code></li> <li><code>byte</code> defaults to <code>0x00</code></li> <li><code>string</code> defaults to <code>\"\"</code></li> <li><code>tetra</code> defaults to <code>false</code></li> <li><code>nothing</code> defaults to <code>nothing</code></li> </ul> <p>This ensures that unions always have a well-defined state and the compiler knows which type is currently active.</p>"},{"location":"unions/#optional-values","title":"Optional Values","text":"<p>A common use case for unions is representing optional values using <code>nothing</code>:</p> <pre><code>// Optional integer\nvar maybe_name :: string | nothing\nmaybe_name is \"Alice\"     // Has a value\nmaybe_name is nothing // No value\n\n// Function that might not return a value\nfunction findValue(arr :: MyObject[], target :: string) returns(int | nothing) {\n    each x in arr {\n        if (x.name equals target) then {\n            return x\n        }\n    }\n    return nothing // Not found\n}\n</code></pre>"},{"location":"unions/#why-unions-are-useful","title":"Why unions are useful","text":"<p>Unions are particularly useful when:</p> <ul> <li>A function can return different types depending on the input</li> <li>A variable needs to hold different types at different times</li> <li>You want to represent optional values (like <code>T | nothing</code>)</li> <li>You're working with data that can have multiple valid representations</li> </ul>"},{"location":"unions/#error-handling","title":"Error Handling","text":"<p>Here is a robust example of how error handling can be done using Doxa. Note that none of this handling is specific to errors, it is a general return pattern which relies on normal values making semanitcs extremely clear and flexible. This relies on the <code>as</code> keyword which attempts to narrow a value into another type.</p> <pre><code>enum ErrorList {\n    Overflow,\n    Underflow,\n}\n\n// Match function to process errors\nfunction handleError(err :: ErrorList) {\n    match err {\n        .Overflow then doSomething(),\n        .Underflow then doSomethingElse(),\n    }\n}\n\n// Function returns a union - we won't know if the value is a number or one of our errors until we check\nfunction addLimit(a :: int, b :: int) returns( int | ErrorList ) {\n    const result is a + b\n    if result &gt; 255 then return ErrorList.Overflow\n    if result &lt; 0 then return ErrorList.Underflow\n    return result\n}\n\n// All of these return unions\nconst unknownBigResult is addLimit(1000, 1000)   // ErrorList.Overflow\nconst unknownSmallResult is addLimit(100, -1000) // ErrorList.Underflow\nconst unknownRightResult is addLimit(100, -10)   // 90\n\n// Handle errors - several approaches:\n\n// Approach 1: Pattern matching (cleanest)\nmatch unknownRightResult {\n    int then onlyUsesInts(unknownRightResult),  // unknownRightResult is typed as int here\n    ErrorList then handleError(unknownRightResult),  // unknownRightResult is typed as ErrorList here\n}\n\n// Approach 2: Explicit fallback with error handling\nconst myInt is unknownRightResult as int else {\n    @panic(\"This should never happen in production!\")\n}\nonlyUsesInts(myInt)\n\n// Note type checking in control flow doesn't implicitly cast unlike match case which is exhaustive\n// this can be done by narrowing within the branch but it is not as ergonomic as match case\nif unknownRightResult @istype int then {\n    onlyUsesInts(unknownRightResult) as int else{}\n} else if unknownRightResult @istype ErrorList then {\n    handleError(unknownRightResult) as ErrorList else{}\n}\n</code></pre>"},{"location":"unions/#type-casting-with-as","title":"Type Casting with <code>as</code>","text":"<p>The <code>as</code> keyword attempts to cast a union to a specific type. If the cast fails, the <code>else</code> block is executed:</p> <pre><code>var value :: int | string\nvalue is \"hello\"\n\n// This will execute the else block since value is currently a string\nconst number is value as int else {\n    return error.ExpectedInteger\n}\n\n// This will succeed since value is now an int\nvalue is 42\nconst doubled is value as int else {\n    return error.ExpectedInteger\n} // doubled is 84\n</code></pre> <p><code>as</code> can be used for control flow as well, using then blocks:</p> <pre><code>// using as like an 'istype' style conditional\nasThenUnion as int then {\n    var result is 20 + 30\n    result?\n} else {\n    var result is 30 + 40\n    result?\n} // 50\n</code></pre>"},{"location":"unions/#common-patterns","title":"Common Patterns","text":"<p>Safe extraction with default:</p> <pre><code>const result is someUnion as int else {\n    return 0 // Default value if not an int\n}\n</code></pre> <p>Error handling:</p> <pre><code>const number is value as int else {\n    @panic(\"This should never happen in production!\")\n}\n</code></pre> <p>Conditional processing:</p> <pre><code>const processed is value as string else {\n    // Handle non-string case\n    return \"default\"\n}\n</code></pre> <p>The <code>as</code> keyword is essential for safely working with unions when you need to extract a specific type.</p>"}]}