{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Doxa","text":"<p>Doxa is a compiled language which focuses on simplicity, readability, and gradualized type safety. It enables seamless transition from prototype to production code through safe and normal directives.</p> <p>Doxa is built using Zig. It's designed to be a highly readable language that brings gradual type safety which is controlled by directives. This allows Doxa to act as a flexible and dynamically typed scripting language while providing the ability to enforce type safety when needed.</p> <p>Here is a comparison of a simple program written in Doxa's normal mode vs safe mode:</p> <pre><code>var x = 1;\nvar y = 2;\n\nfn add(a, b) {\n    return (a + b);\n}\n\nadd(x, y);\n</code></pre> <pre><code>#safe\n\nfn add(a: int, b: int) returns(int) {\n    return (a + b);\n}\n\n-&gt; fn main() {\n    var a: int = 1;\n    var b: int = 2;\n\n    add(a, b);\n}\n</code></pre> <p>The normal mode is a superset of the safe mode. This means that any valid safe mode code is also valid normal mode code. Transition from prototype to production code is aided by the use of the <code>#warn</code> directive. Warn mode will compile the code in normal mode but provides warnings where safe syntax isn't followed.</p>"},{"location":"syntax/","title":"Doxa Language Reference","text":""},{"location":"syntax/#modes-of-operation","title":"Modes of Operation","text":"<p>Doxa supports three operational modes:</p> <ul> <li>Normal Mode (default): Dynamic typing with flexible syntax</li> <li>Safe Mode: Enabled via <code>#safe</code> at file start, enforces static typing</li> <li>Warn Mode: Compiles in normal mode but warns about safe convention violations</li> </ul> <p>Note</p> <p>Safe files can only import other safe files, while normal files can import both.</p>"},{"location":"syntax/#core-language-features","title":"Core Language Features","text":""},{"location":"syntax/#syntax-alternatives","title":"Syntax Alternatives","text":"<p>Doxa provides alternative syntax for common operations. Using mixed styles in the same file triggers warnings.</p> Primary Alternative Purpose <code>and</code> <code>&amp;&amp;</code> Logical AND <code>or</code> <code>\\|\\|</code> Logical OR <code>equals</code> <code>==</code> Equality <code>where</code> <code>\\|</code> Filter conditions <code>function</code> <code>fn</code> Function declaration"},{"location":"syntax/#type-system","title":"Type System","text":"<ul> <li>No operator or function overloading</li> <li>No classes, only structs and composition</li> <li>Garbage collected memory management</li> </ul>"},{"location":"syntax/#basic-composition-example","title":"Basic Composition Example","text":"<pre><code>struct Animal {\n    name: string\n}\n\nstruct Dog {\n    // Composition instead of inheritance\n    animal: Animal,\n    breed: string,\n\n    fn bark(self) {\n        print(\"${self.animal.name} says woof!\");\n    }\n}\n\nvar dog = Dog {\n    animal: Animal { name: \"Spot\" },\n    breed: \"Labrador\"\n};\n</code></pre>"},{"location":"syntax/#modules","title":"Modules","text":"<pre><code>// math.doxa\n#safe\nexport fn add(a: int, b: int) -&gt; int {\n    return a + b;\n}\n\n// main.doxa\nimport { add } from \"./math.doxa\";\nvar sum = add(1, 2);\n</code></pre>"},{"location":"syntax/#data-types","title":"Data Types","text":""},{"location":"syntax/#arrays","title":"Arrays","text":"<p>Arrays are homogeneous collections with type inference:</p> <pre><code>var nums = [1, 2, 3];             // Inferred as int[]\nvar strs = [\"a\", \"b\"];            // Inferred as string[]\nvar explicit: int[] = [1, 2, 3];  // Explicit typing\n\n// Invalid operations\nvar mixed = [1, \"two\", true];     // Error: mixed types\nnums.push(\"four\");                // Error: type mismatch\n</code></pre>"},{"location":"syntax/#tuples","title":"Tuples","text":"<p>Fixed-size collections supporting different types:</p> <pre><code>var point = (10, 20, 30);         // Simple tuple\nvar nested = ((1, 2), (3, 4));    // Nested tuple\n\npoint[0];                         // Access first element\nnested[1][0];                     // Access nested element\n</code></pre>"},{"location":"syntax/#maps","title":"Maps","text":"<p>String-keyed dictionaries:</p> <pre><code>var scores = {\n    \"alice\": 100,\n    \"bob\": 85\n};\nscores[\"alice\"];                  // Access value\n</code></pre>"},{"location":"syntax/#control-flow","title":"Control Flow","text":""},{"location":"syntax/#pattern-matching","title":"Pattern Matching","text":"<pre><code>enum Status { Success, Error, Pending }\n\nvar result = match status {\n    .Success =&gt; \"all good\",\n    .Error =&gt; \"failed\",\n    else =&gt; \"waiting\"\n};\n</code></pre> <p>Warning</p> <p>Match expressions must be exhaustive or include an <code>else</code> clause.</p>"},{"location":"syntax/#error-handling","title":"Error Handling","text":"<pre><code>try {\n    riskyOperation();\n} catch {\n    handleError();\n}\n</code></pre>"},{"location":"syntax/#special-operators","title":"Special Operators","text":""},{"location":"syntax/#inspect","title":"Inspect (<code>?</code>)","text":"<pre><code>var x = computeValue();\nx?;                              // Prints value with location\n</code></pre>"},{"location":"syntax/#type-information","title":"Type Information","text":"<pre><code>typeof(42);                      // \"int\"\ntypeof(\"hello\");                // \"string\"\ntypeof([1,2,3]);               // \"array\"\n</code></pre>"},{"location":"syntax/#collection-quantifiers","title":"Collection Quantifiers","text":"<pre><code>exists x in numbers where x &gt; 10  // Any match\nforall x in numbers | x &gt; 0      // All match\n</code></pre>"},{"location":"syntax/#type-system-details","title":"Type System Details","text":""},{"location":"syntax/#normal-mode","title":"Normal Mode","text":"<p>Variables are dynamically typed by default:</p> <pre><code>var x = 1;                      // int\nx = true;                       // bool (allowed)\n\nvar y: auto = 3.14;            // float\ny = \"pi\";                      // string (allowed)\n</code></pre>"},{"location":"syntax/#safe-mode","title":"Safe Mode","text":"<p>Variables require explicit typing:</p> <pre><code>var x: int;                    // Valid declaration\nvar x = \"two\";                // Error: needs type\nvar x: auto = 3.14;           // Type locked to float\nx = \"five\";                   // Error: type mismatch\n</code></pre> <p>Explicit return type declarations are required:</p> <pre><code>// Safe Mode - Valid\nfn greet(name: string) -&gt; string {\n    return \"Hello ${name}!\";\n}\n\n// Safe Mode - Error: missing return type\nfn greet(name: string) {\n    return \"Hello ${name}!\";\n}\n</code></pre>"},{"location":"syntax/#conditional-expressions","title":"Conditional Expressions","text":"<p>All conditionals are expressions and return values:</p> <pre><code>var result = if condition then {\n    value1\n} else {\n    value2\n};\n</code></pre> <p>Note</p> <p>Expressions without a value return <code>nothing</code>: <code>doxa     var x = if (false) { y = 1 };  // x becomes nothing</code></p>"},{"location":"syntax/#function-return-types","title":"Function Return Types","text":"<p>Functions can specify return types using either <code>-&gt;</code> or <code>returns</code> syntax:</p> <pre><code>fn add(a: int, b: int) -&gt; int {\n    return a + b;\n}\n\n// Alternative syntax\nfn add(a: int, b: int) returns(int) {\n    return a + b;\n}\n</code></pre> <p>return types are optional and inferred by default:</p> <pre><code>// Normal Mode - Valid\nfn add(a, b) {\n    return a + b;\n}\n</code></pre>"}]}