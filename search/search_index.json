{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Doxa","text":"<pre><code>Everything is real and is not real,\nBoth real and not real,\nNeither real nor not real.\nThis is Lord Buddha\u2019s teaching.\n\n- N\u0101g\u0101rjuna\n    Verses on the Middle Way (2nd\u20133rd century CE)\n</code></pre> <p>Doxa is a simple to write, highly readible language based on four corned logic inspired by the logic of Nagarjuna. In Doxa there are no booleans. Doxa instead uses a four cournered logical unit called a tetra. Tetras can represent true and false, which act as you would expect them to in a traditional programing language.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Language Syntax - Complete language reference</li> <li>Tetras - Four-cornered logic system</li> <li>SOXA Format - Binary intermediate representation and execution format</li> </ul>"},{"location":"alias/","title":"Alias","text":"<p>Alias Parameters (^)</p> <p>Overview Alias parameters allow a function to modify a caller\u2019s variable directly, without general-purpose pointers or references. They are opt-in at both the function signature and call site, making mutations explicit and safe. Aliases are stack-bound, cannot escape their defining function, and cannot be taken from partial subfields or array elements.</p> <p>Syntax</p> <p>fn modify(^param :: int) { param += 1; // Directly mutates caller's variable }</p> <p>var x = 0; modify(^x); // Caller opts-in to mutation // x == 1</p> <p>Core Rules</p> <pre><code>Parameter-only \u2014 ^T may only appear in function parameters, never in locals, returns, or stored types.\n\nLvalue-only \u2014 Only full variables can be aliased; no temporaries, expressions, struct fields, or array elements.\n\nExplicit call-site \u2014 Caller must pass ^var to grant mutation rights.\n\nNo alias duplication \u2014 The same variable cannot be passed to more than one alias parameter in the same call.\n\nNo alias + by-value mix \u2014 A variable cannot be passed aliased and by-value in the same call.\n\nNo escaping \u2014 Aliases cannot be returned, stored, or captured by closures.\n\nNo address-of \u2014 Taking &amp; of an alias parameter is forbidden.\n\nNo async/threads \u2014 Aliases are banned in async functions and cannot be passed to concurrent tasks.\n\nExclusive borrow \u2014 Aliases grant exclusive mutable access for the duration of the call; no overlapping borrows allowed.\n\nFFI control \u2014 Passing aliases to foreign code requires explicit unsafe or noescape annotation.\n\nEvaluation order \u2014 Arguments evaluate left-to-right, but banned alias patterns remain errors.\n</code></pre> <p>Example: Safe Swap</p> <p>fn swap(^a :: int, ^b :: int) { let tmp is a; a is b; b is tmp; }</p> <p>var x is 1, y is 2; swap(^x, ^y); // x == 2, y == 1</p> <p>Example: Compile-time Error Cases</p> <p>swap(^x, ^x); // \u274c same variable passed twice modify(^(x + 1)); // \u274c temporaries not allowed f(^obj.field); // \u274c partial object aliasing not allowed g(^x, x); // \u274c aliased and by-value in same call</p> <p>Design Intent This model offers mutation semantics without full pointers, preserving deterministic lifetime and memory safety under stack-based allocation. By forcing explicit syntax and disallowing escaping or partial aliasing, it avoids common pitfalls of traditional references while retaining enough flexibility for in-place updates.</p>"},{"location":"control/","title":"Control","text":""},{"location":"control/#control-flow","title":"Control Flow","text":"<p>Doxa unifies conditional branching with a consistent then / else pattern across if, as, and match.</p>"},{"location":"control/#core-rules","title":"Core rules","text":"<ul> <li>Expression bodies end with a semicolon; block bodies <code>{ ... }</code> are self-terminating (no extra semicolon after the closing brace).</li> <li>then attaches the success branch where applicable; else attaches the failure/default branch and does not use then.</li> <li>These rules apply consistently to if, as, and match.</li> </ul>"},{"location":"control/#if-then-else","title":"if / then / else","text":"<ul> <li>then required, else optional.</li> <li>Body can be an expression (end with <code>;</code>) or a block <code>{ ... }</code> (no trailing <code>;</code>).</li> </ul> <p>Examples:</p> <pre><code>// Block bodies (no trailing semicolons)\nif x &gt; 10 then {\n    \"x is greater than 10\"?;\n} else {\n    \"x is 10 or less\"?;\n}\n\n// Expression body (ends with semicolon)\nvar condition is if true then \"true\" else \"false\";\n</code></pre> <p>Chaining and statement-style:</p> <pre><code>if current % 3 equals 0 and current % 5 equals 0 then \"fizzbuzz\"?;\nelse if current % 3 equals 0 then \"fizz\"?;\nelse if current % 5 equals 0 then \"buzz\"?;\nelse current?;\n</code></pre>"},{"location":"control/#as-then-else-type-narrowing","title":"as / then / else (type narrowing)","text":"<ul> <li>else required, then optional.</li> <li>Same body rules: expression bodies end with <code>;</code>, block bodies do not.</li> </ul> <p>Examples:</p> <pre><code>// Success and failure as expressions\nconst n_or_zero is value as int else 0;\n\n// Block failure case\nvalue as int else {\n    \"value is not an int\"?;\n};\n\n// Explicit success block\nvalue as int then {\n    // use the narrowed int value here\n} else {\n    // handle non-int here\n}\n</code></pre>"},{"location":"control/#if-vs-as","title":"if vs as","text":"<p>In Doxa, if and as both use the then / else pattern, but they invert the emphasis:</p> Keyword Requires Optional Implied meaning if then else If success then do x, failure branch optional as else then As a type or else do x, success branch optional <p><code>if</code> is a keyword which implicitly requires a success condition, <code>as</code> implicity requires a fail condition, but both use then/else blocks in the same way.</p> <p>Examples</p> <pre><code>// IF: Truth-driven\nif x &gt; 10 then \"big\"? else \"small\"?;\n\n// AS: Fallback-driven\nvalue as int else 0;        // If not int, use 0\nvalue as int then 20 else 0; // If int, use 20; else 0\n\n// Both in action\nif isReady then start() else wait();\ndata as string then parse(data) else log(\"Bad data\");\n</code></pre>"},{"location":"control/#match-values-and-union-types","title":"match (values and union types)","text":"<p>Use match to branch on:</p> <ul> <li>Concrete values: numbers, strings, enum variants (<code>.Red</code>, <code>.Green</code>, ...)</li> <li>Union type arms: <code>int</code>, <code>float</code>, <code>string</code>, <code>byte</code>, <code>tetra</code>, <code>nothing</code>, or custom types</li> </ul> <p>Arm syntax and delimiters:</p> <ul> <li>Pattern arms: <code>pattern then BODY</code></li> <li>Else arm: <code>else BODY</code> (no then)</li> <li>Body: expression (end with <code>;</code>) or block <code>{ ... }</code> (no trailing <code>;</code>)</li> <li>Arms are separated by either the semicolon of an expression body, or by the end of a block body</li> </ul> <p>Match on union types:</p> <pre><code>fn kind(value :: int | float) returns(string) {\n    return match value {\n        int then \"integer\"?;\n        float then \"float\"?;\n    };\n}\n</code></pre> <p>Match on enums and values:</p> <pre><code>enum Color { Red, Green, Blue }\n\nvar msg1 is match color {\n    .Red then \"It's red\";\n    .Blue then \"It's blue\";\n    else \"It's something else\";\n};\n\nconst x is 5;\nvar msg2 is match x {\n    0 then \"It's zero\";\n    5 then \"It's five\";\n    else \"It's something else\";\n};\n\nconst s is \"big\";\nvar msg3 is match s {\n    \"big\" then \"It's big\";\n    \"small\" then \"It's small\";\n    else \"It's something else\";\n};\n</code></pre> <p>Block arms in match:</p> <pre><code>var msg is match color {\n    .Red then { \"stop\"?; \"red\"; }\n    .Green then \"green\";\n    else { \"caution\"?; \"yellowish\"; }\n};\n</code></pre> <p>Notes:</p> <ul> <li>Exhaustiveness: For enums, prefer covering all variants or add an <code>else</code> arm. For unions, cover the needed type arms; <code>else</code> is optional.</li> <li>Result type: All arms must produce a compatible result type. For block arms, the last expression is the arm\u2019s value.</li> </ul>"},{"location":"control/#quick-reference","title":"Quick reference","text":"<ul> <li>if: then required; else optional; expression body ends with <code>;</code>, block body does not.</li> <li>as: else required; then optional; same body rules.</li> <li>match: pattern then BODY; else BODY; arm separation via expression <code>;</code> or closing block <code>}</code>.</li> </ul>"},{"location":"loops/","title":"Loops","text":"<p>Doxa provides three types of loops: <code>while</code>, <code>for</code>, and <code>each</code>. While <code>while</code> and <code>for</code> work like traditional loops in most languages, <code>each</code> offers a more modern, collection-focused approach.</p>"},{"location":"loops/#while","title":"While","text":"<p>The <code>while</code> loop continues executing as long as a condition remains true:</p> <pre><code>var currentNumber is 0;\nwhile currentNumber &lt;= 100 {\n    currentNumber += 1;\n}\n</code></pre>"},{"location":"loops/#for","title":"For","text":"<p>The <code>for</code> loop uses traditional C-style syntax with initialization, condition, and increment:</p> <pre><code>for (var i is 0; i &lt; x; i++) {\n    doSomething(myArray[i]);\n}\n</code></pre>"},{"location":"loops/#each","title":"Each","text":"<p>The <code>each</code> loop is Doxa's modern iteration construct for collections. It's cleaner and safer than indexed loops:</p> <pre><code>each x in arr {\n    doSomething(x);\n}\n</code></pre>"},{"location":"loops/#each-with-index","title":"Each with Index","text":"<p>You can also access the index using the <code>at</code> keyword:</p> <pre><code>each x at i in arr {\n    if i &lt; 3 then doSomething(x);\n}\n</code></pre> <p>The <code>each</code> loop eliminates the need for manual index management and reduces the risk of off-by-one errors that are common with traditional <code>for</code> loops.</p>"},{"location":"methods/","title":"Built-in Methods","text":"<p>Doxa provides built-in methods prefixed with <code>@</code> for core operations. These methods are fundamental to the language and don't require imports.</p>"},{"location":"methods/#categories","title":"Categories","text":"<ul> <li>Array Methods</li> <li>String Methods</li> <li>Math Methods</li> <li>Type Methods</li> <li>I/O Methods</li> <li>Control Flow Methods</li> </ul>"},{"location":"methods/#method-documentation-format","title":"Method Documentation Format","text":"<p>Each method is documented with:</p> <ul> <li>Input: Parameters and their types</li> <li>Output: Return value and type</li> <li>Modifies: Any side effects</li> <li>Errors: Possible error conditions</li> <li>Example: Usage example</li> </ul>"},{"location":"methods/#array-methods","title":"Array Methods","text":""},{"location":"methods/#length","title":"length","text":"<p>Input:</p> <ul> <li>x :: string | array // Type checked at compile time</li> </ul> <p>Output:</p> <ul> <li>Integer length of the input</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Example:</p> <ul> <li>var x = \"hello\"; @length(x) -&gt; 5</li> </ul>"},{"location":"methods/#push","title":"push","text":"<p>Input:</p> <ul> <li>source :: array // Type checked at compile time</li> <li>value :: any // Type checked at compile time</li> </ul> <p>Output:</p> <ul> <li>nothing</li> </ul> <p>Modifies:</p> <ul> <li>Adds value to end of source array</li> </ul> <p>Runtime Errors:</p> <ul> <li>CapacityExceeded: if array would exceed maximum size</li> <li>OutOfMemory: if system cannot allocate memory</li> </ul> <p>Example:</p> <pre><code>var arr = [1, 2];\n@push(arr, 3) else {\n    @panic(\"Failed to add element\");\n};\n// arr is now [1, 2, 3]\n</code></pre>"},{"location":"methods/#pop","title":"pop","text":"<p>Input:</p> <ul> <li>source: array to modify</li> </ul> <p>Output:</p> <ul> <li>Last element from array</li> </ul> <p>Modifies:</p> <ul> <li>Removes last element from source array</li> <li>Original array is modified in place</li> <li>Array length decreases by 1</li> </ul> <p>Errors:</p> <ul> <li>EmptyArray: if array has no elements</li> </ul> <p>Notes:</p> <ul> <li>Modifies the original array</li> <li>Cannot be undone (use @copy first if needed)</li> <li>Returns the removed element</li> </ul> <p>Example:</p> <pre><code>var arr = [1, 2, 3];\nvar last = @pop(arr);     // last is 3\n@length(arr) == 2;        // array now has 2 elements\narr == [1, 2];           // original array is modified\n\n// Save array before popping\nvar backup = @copy(arr);\nvar item = @pop(arr);    // only modifies arr, not backup\n</code></pre>"},{"location":"methods/#insert","title":"insert","text":"<p>Input:</p> <ul> <li>source: array to modify</li> <li>index: position to insert at</li> <li>value: element to insert</li> </ul> <p>Output:</p> <ul> <li>nothing</li> </ul> <p>Modifies:</p> <ul> <li>Inserts value at index, shifts existing elements right</li> </ul> <p>Errors:</p> <ul> <li>IndexOutOfBounds: if index &lt; 0 or index &gt; array length</li> <li>OutOfMemory: if array cannot be expanded</li> </ul> <p>Example:</p> <ul> <li>var arr = [1, 2]; @insert(arr, 1, 5); // arr is now [1, 5, 2]</li> </ul>"},{"location":"methods/#remove","title":"remove","text":"<p>Input:</p> <ul> <li>source: array to modify</li> <li>index: position to remove from</li> </ul> <p>Output:</p> <ul> <li>Removed element</li> </ul> <p>Modifies:</p> <ul> <li>Removes element at index, shifts remaining elements left</li> </ul> <p>Errors:</p> <ul> <li>IndexOutOfBounds: if index &lt; 0 or index &gt;= array length</li> </ul> <p>Example:</p> <ul> <li>var arr = [1, 2, 3]; var removed = @remove(arr, 1); // removed is 2, arr is [1, 3]</li> </ul>"},{"location":"methods/#clear","title":"clear","text":"<p>Input:</p> <ul> <li>source: array to clear</li> </ul> <p>Output:</p> <ul> <li>nothing</li> </ul> <p>Modifies:</p> <ul> <li>Removes all elements from array</li> </ul> <p>Runtime Errors:</p> <ul> <li>None</li> </ul> <p>Example:</p> <ul> <li>var arr = [1, 2, 3]; @clear(arr); // arr is now []</li> </ul>"},{"location":"methods/#index","title":"index","text":"<p>Input:</p> <ul> <li>source: array or string to search</li> <li>value: element to find</li> </ul> <p>Output:</p> <ul> <li>Index of first occurrence, or -1 if not found</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Runtime Errors:</p> <ul> <li>None or string</li> </ul> <p>Example:</p> <ul> <li>var arr = [1, 2, 3]; var idx = @index(arr, 2); // idx is 1</li> </ul>"},{"location":"methods/#clone","title":"clone","text":"<p>Input:</p> <ul> <li>value :: array | string | map</li> </ul> <p>Output:</p> <ul> <li>Deep copy of the input value (recursively copies all nested structures)</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Runtime Errors:</p> <ul> <li>None</li> </ul> <p>Notes:</p> <ul> <li>Creates completely independent copy</li> <li>Recursively copies all nested arrays and maps</li> <li>Nested values have no connection to original</li> <li>Safe for circular references</li> </ul> <p>Example:</p> <pre><code>var nested = [1, [2, 3], {\"x\": [4, 5]}];\nvar deep = @clone(nested);\ndeep[1][0] = 9;        // modifies copy only\nnested[1][0] == 2;     // original unchanged\n</code></pre>"},{"location":"methods/#copy","title":"copy","text":"<p>Input:</p> <ul> <li>value :: array | string | map</li> </ul> <p>Output:</p> <ul> <li>Shallow copy of the input value (copies only top-level structure)</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Runtime Errors:</p> <ul> <li>None</li> </ul> <p>Notes:</p> <ul> <li>Creates new top-level container only</li> <li>Nested structures are shared with original</li> <li>Modifying nested values affects both copies</li> <li>Faster than deep copy for simple structures</li> </ul> <p>Example:</p> <pre><code>var nested = [1, [2, 3]];\nvar shallow = @copy(nested);\nshallow[0] = 9;        // modifies copy only\nshallow[1][0] = 9;     // modifies both copies!\nnested[1][0] == 9;     // shared nested array\n</code></pre>"},{"location":"methods/#string-methods","title":"String Methods","text":""},{"location":"methods/#split","title":"split","text":"<p>Input:</p> <ul> <li>source :: string</li> <li>delimiter :: string</li> </ul> <p>Output:</p> <ul> <li>Array of strings split by delimiter</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Runtime Errors:</p> <ul> <li>None</li> </ul> <p>Example:</p> <ul> <li>var str = \"a,b,c\"; var parts = @split(str, \",\"); // parts is [\"a\", \"b\", \"c\"]</li> </ul>"},{"location":"methods/#join","title":"join","text":"<p>Input:</p> <ul> <li>source :: array</li> <li>delimiter :: string</li> </ul> <p>Output:</p> <ul> <li>String with array elements joined by delimiter</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Runtime Errors:</p> <ul> <li>None or delimiter is not a string</li> </ul> <p>Example:</p> <ul> <li>var arr = [\"a\", \"b\", \"c\"]; var str = @join(arr, \",\"); // str is \"a,b,c\"</li> </ul>"},{"location":"methods/#slice","title":"slice","text":"<p>Input:</p> <ul> <li>source: array or string to slice</li> <li>start: starting index (inclusive)</li> <li>end: ending index (exclusive)</li> </ul> <p>Output:</p> <ul> <li>New array or string containing elements from start to end</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Runtime Errors:</p> <ul> <li>None or string</li> <li>IndexOutOfBounds: if start &lt; 0 or end &gt; length</li> <li>InvalidArgument: if start &gt; end</li> </ul> <p>Example:</p> <ul> <li>var arr = [1, 2, 3, 4]; var sliced = @slice(arr, 1, 3); // sliced is [2, 3]</li> </ul>"},{"location":"methods/#bytes","title":"bytes","text":"<p>Input:</p> <ul> <li>value: string to convert</li> </ul> <p>Output:</p> <ul> <li>Array of byte values</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Runtime Errors:</p> <ul> <li>None</li> </ul> <p>Example:</p> <ul> <li>var str = \"ABC\"; var bytes = @bytes(str); // bytes is [65, 66, 67]</li> </ul>"},{"location":"methods/#trim","title":"trim","text":"<p>Input:</p> <ul> <li>value :: string</li> </ul> <p>Output:</p> <ul> <li>String with leading and trailing whitespace removed</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Runtime Errors:</p> <ul> <li>None</li> </ul> <p>Example:</p> <ul> <li>var str = \" hello \"; var trimmed = @trim(str); // trimmed is \"hello\"</li> </ul>"},{"location":"methods/#lower","title":"lower","text":"<p>Input:</p> <ul> <li>value :: string</li> </ul> <p>Output:</p> <ul> <li>String converted to lowercase</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Runtime Errors:</p> <ul> <li>None</li> </ul> <p>Example:</p> <ul> <li>var str = \"Hello\"; var lower = @lower(str); // lower is \"hello\"</li> </ul>"},{"location":"methods/#upper","title":"upper","text":"<p>Input:</p> <ul> <li>value :: string</li> </ul> <p>Output:</p> <ul> <li>String converted to uppercase</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Runtime Errors:</p> <ul> <li>None</li> </ul> <p>Example:</p> <ul> <li>var str = \"Hello\"; var upper = @upper(str); // upper is \"HELLO\"</li> </ul>"},{"location":"methods/#math-methods","title":"Math Methods","text":""},{"location":"methods/#abs","title":"abs","text":"<p>Input:</p> <ul> <li>value :: int | float</li> </ul> <p>Output:</p> <ul> <li>Absolute value of the input</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Runtime Errors:</p> <ul> <li>None</li> </ul> <p>Example:</p> <ul> <li>var x = -5; var abs = @abs(x); // abs is 5</li> </ul>"},{"location":"methods/#min","title":"min","text":"<p>Input:</p> <ul> <li>a :: int | float</li> <li>b :: int | float</li> </ul> <p>Output:</p> <ul> <li>Smaller of the two values</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Runtime Errors:</p> <ul> <li>None</li> </ul> <p>Example:</p> <ul> <li>var min = @min(5, 3); // min is 3</li> </ul>"},{"location":"methods/#max","title":"max","text":"<p>Input:</p> <ul> <li>a :: int | float</li> <li>b :: int | float</li> </ul> <p>Output:</p> <ul> <li>Larger of the two values</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Runtime Errors:</p> <ul> <li>None</li> </ul> <p>Example:</p> <ul> <li>var max = @max(5, 3); // max is 5</li> </ul>"},{"location":"methods/#round","title":"round","text":"<p>Input:</p> <ul> <li>value :: float</li> </ul> <p>Output:</p> <ul> <li>Rounded integer value</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Runtime Errors:</p> <ul> <li>None</li> </ul> <p>Example:</p> <ul> <li>var x = 3.7; var rounded = @round(x); // rounded is 4</li> </ul>"},{"location":"methods/#floor","title":"floor","text":"<p>Input:</p> <ul> <li>value :: float</li> </ul> <p>Output:</p> <ul> <li>Largest integer less than or equal to value</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Runtime Errors:</p> <ul> <li>None</li> </ul> <p>Example:</p> <ul> <li>var x = 3.7; var floor = @floor(x); // floor is 3</li> </ul>"},{"location":"methods/#ceil","title":"ceil","text":"<p>Input:</p> <ul> <li>value :: float</li> </ul> <p>Output:</p> <ul> <li>Smallest integer greater than or equal to value</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Runtime Errors:</p> <ul> <li>None</li> </ul> <p>Example:</p> <ul> <li>var x = 3.2; var ceil = @ceil(x); // ceil is 4</li> </ul>"},{"location":"methods/#type-methods","title":"Type Methods","text":""},{"location":"methods/#string","title":"string","text":"<p>Input:</p> <ul> <li>value: any value to convert</li> </ul> <p>Output:</p> <ul> <li>String representation of value</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Errors:</p> <ul> <li>None (all values can be converted to string)</li> </ul> <p>Example:</p> <ul> <li>var num = 123; var str = @string(num); // str is \"123\"</li> </ul>"},{"location":"methods/#int","title":"int","text":"<p>Input:</p> <ul> <li>value :: string // Type checked at compile time</li> </ul> <p>Output:</p> <ul> <li>Integer value | NumberParseError</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Runtime Errors:</p> <ul> <li>ParseFailed: if string is not a valid number format</li> <li>Overflow: if number is too large for int type</li> <li>Underflow: if number is too small for int type</li> </ul> <p>Example:</p> <pre><code>// Basic parsing\nvar str = \"123\";\nvar num = @int(str) else {\n    @panic(\"Not a valid number\");\n};\n\n// Handle specific errors\nvar result = @int(\"-999999999999\") match {\n    int then it,                    // Successfully parsed\n    ParseFailed then 0,            // Not a number\n    Overflow then MaxInt,          // Too large\n    Underflow then MinInt,         // Too small\n    else =&gt; 0\n};\n</code></pre>"},{"location":"methods/#float","title":"float","text":"<p>Input:</p> <ul> <li>value: string to convert</li> </ul> <p>Output:</p> <ul> <li>Float value, or 0.0 if conversion fails</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Runtime Errors:</p> <ul> <li>None</li> </ul> <p>Example:</p> <ul> <li>var str = \"123.45\"; var num = @float(str); // num is 123.45</li> </ul>"},{"location":"methods/#type","title":"type","text":"<p>Input:</p> <ul> <li>value: any value to check</li> </ul> <p>Output:</p> <ul> <li>String name of value's type</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Errors:</p> <ul> <li>None</li> </ul> <p>Example:</p> <ul> <li>var arr = [1, 2]; var type = @type(arr); // type is \"array\"</li> </ul>"},{"location":"methods/#io-methods","title":"I/O Methods","text":""},{"location":"methods/#input","title":"input","text":"<p>Input:</p> <ul> <li>none</li> </ul> <p>Output:</p> <ul> <li>string containing the line read from standard input</li> <li>empty string (\"\") on EOF or if no data is available</li> </ul> <p>Modifies:</p> <ul> <li>Blocks until a line is available or EOF is reached</li> </ul> <p>Errors:</p> <ul> <li>IOError: if input stream fails (e.g., terminal disconnected)</li> </ul> <p>Notes:</p> <ul> <li>Blocks execution until a complete line is available</li> <li>Line includes all characters up to but not including the newline</li> <li>Returns empty string on EOF rather than raising an error</li> <li>Use in loop to read all lines: <code>while (line = @input()) != \"\" { ... }</code></li> </ul> <p>Example:</p> <pre><code>// Basic input\nvar name = @input(); // blocks until line available\n\n// Reading all lines\nvar lines = [];\nvar line = \"\";\nwhile (line = @input()) != \"\" {\n    @push(lines, line);\n}\n</code></pre>"},{"location":"methods/#read","title":"read","text":"<p>Input:</p> <ul> <li>path :: string - Path to file to read</li> </ul> <p>Output:</p> <ul> <li>string containing file contents</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Errors:</p> <ul> <li>IOError: if file cannot be read</li> <li>PathError: if path is invalid</li> </ul> <p>Example:</p> <ul> <li>var content is @read(\"config.txt\");</li> </ul>"},{"location":"methods/#write","title":"write","text":"<p>Input:</p> <ul> <li>path :: string - Path to file to write</li> <li>content :: string - Content to write</li> </ul> <p>Output:</p> <ul> <li>tetra indicating success (true) or failure (false)</li> </ul> <p>Modifies:</p> <ul> <li>Creates or overwrites file at path</li> </ul> <p>Errors:</p> <ul> <li>IOError: if file cannot be written</li> <li>PathError: if path is invalid</li> </ul> <p>Example:</p> <ul> <li>var success is @write(\"log.txt\", \"Hello\");</li> </ul>"},{"location":"methods/#binary-io-and-encoding","title":"Binary I/O and Encoding","text":"<p>Doxa handles binary data through composition of string and byte array operations:</p> <p>Reading binary files:</p> <pre><code>// Read file as raw bytes\nvar raw = @read(\"image.png\");    // reads file as-is, no encoding\nvar bytes = @bytes(raw);         // convert to byte array\nvar firstByte = bytes[0];        // access individual bytes\n\n// Text file with specific encoding\nvar text = @read(\"text.txt\");    // reads as UTF-8 by default\nvar utf8Bytes = @bytes(text);    // get UTF-8 byte representation\n</code></pre> <p>Writing binary files:</p> <pre><code>// Write raw binary data\nvar bytes = [0x89, 0x50, 0x4E, 0x47];  // PNG header bytes\nvar raw = @string(bytes);               // convert to raw string (preserves bytes)\nvar success = @write(\"file.png\", raw);  // writes bytes as-is\n\n// Write text with encoding\nvar text = \"Hello, \u4e16\u754c\";               // UTF-8 text\nvar success = @write(\"hello.txt\", text); // writes as UTF-8\n</code></pre> <p>Notes on Binary Data:</p> <ul> <li><code>@read</code> reads file contents as-is, preserving all bytes</li> <li><code>@write</code> writes raw bytes without modification</li> <li><code>@bytes</code> converts string to its underlying bytes</li> <li><code>@string</code> with byte array preserves raw bytes (no encoding/decoding)</li> <li>Text files use UTF-8 encoding by default</li> <li>No data loss occurs when converting between bytes and raw strings</li> </ul>"},{"location":"methods/#exec","title":"exec","text":"<p>Input:</p> <ul> <li>command :: string - Command to execute</li> </ul> <p>Output:</p> <ul> <li>string containing command output (stdout and stderr combined)</li> </ul> <p>Modifies:</p> <ul> <li>May modify system state depending on command</li> <li>Blocks until command completes</li> </ul> <p>Errors:</p> <ul> <li>ExecError: if command fails to execute</li> <li>SecurityError: if command is not allowed</li> </ul> <p>Notes:</p> <ul> <li>Captures both stdout and stderr in output</li> <li>Blocks until command completes</li> <li>Returns all output as UTF-8 text</li> <li>Command runs with same permissions as Doxa program</li> <li>Use @spawn for non-blocking execution</li> </ul> <p>Example:</p> <pre><code>// Basic usage\nvar status = @exec(\"git status\");\n\n// Handle command failure\nvar result = @exec(\"git push\") else {\n    @panic(\"Git push failed\");\n};\n\n// Capture and process output\nvar files = @exec(\"ls\");\nvar count = @length(@split(files, \"\\n\"));\n</code></pre>"},{"location":"methods/#spawn","title":"spawn","text":"<p>Input:</p> <ul> <li>command :: string - Command to execute asynchronously</li> </ul> <p>Output:</p> <ul> <li>tetra indicating if command started successfully (true)</li> <li>does NOT indicate process completion or success</li> </ul> <p>Modifies:</p> <ul> <li>May modify system state depending on command</li> <li>Process continues running after function returns</li> <li>No way to get process output or result</li> <li>Process may outlive the Doxa program</li> </ul> <p>Errors:</p> <ul> <li>ExecError: if command fails to start</li> <li>SecurityError: if command is not allowed</li> </ul> <p>Notes:</p> <ul> <li>Only indicates if process started, not if it succeeded</li> <li>Use @exec if you need the command's output</li> <li>Spawned process runs independently</li> <li>No built-in way to check process status</li> <li>Useful for long-running background tasks</li> </ul> <p>Example:</p> <pre><code>// Start a long process\nvar started = @spawn(\"long_process\");\n@assert(started, \"Process failed to start\");\n\n// Process runs in background while main program continues\n@print(\"Main program continues...\");\n</code></pre>"},{"location":"methods/#control-flow-methods","title":"Control Flow Methods","text":""},{"location":"methods/#assert","title":"assert","text":"<p>Input:</p> <ul> <li>condition: boolean expression to check</li> <li>message: error message if condition is false</li> </ul> <p>Output:</p> <ul> <li>nothing if condition is true</li> <li>panics with message if condition is false</li> </ul> <p>Modifies:</p> <ul> <li>No modifications</li> </ul> <p>Runtime Errors:</p> <ul> <li>Panic: if condition is false</li> </ul> <p>Example:</p> <ul> <li>var x = 5; @assert(x &gt; 0, \"x must be positive\");</li> </ul>"},{"location":"methods/#panic","title":"panic","text":"<p>Input:</p> <ul> <li>message: error message</li> </ul> <p>Output:</p> <ul> <li>Halts program with error message</li> </ul> <p>Modifies:</p> <ul> <li>Stops program execution</li> </ul> <p>Runtime Errors:</p> <ul> <li>None</li> </ul> <p>Example:</p> <ul> <li>@panic(\"Fatal error occurred\");</li> </ul>"},{"location":"methods/#method-naming-conventions","title":"Method Naming Conventions","text":"<ol> <li> <p>Case:</p> </li> <li> <p>All methods use lowercase</p> </li> <li> <p>No camelCase or PascalCase</p> </li> <li> <p>Type Conversions:</p> </li> <li> <p>Direct names: @string, @int, @float</p> </li> <li> <p>No 'to' prefix</p> </li> <li> <p>Collections:</p> </li> <li> <p>Array operations use verb forms: @push, @pop, @remove</p> </li> <li> <p>Queries use established terms: @length, @index</p> </li> <li> <p>Control Flow:</p> </li> <li> <p>Simple, lowercase forms: @assert, @panic</p> </li> <li> <p>I/O Operations:</p> </li> <li>Simple verbs: @read, @write, @exec<ul> <li>All methods are single words</li> <li>Binary I/O uses composition: @bytes and @string with @read/@write</li> </ul> </li> </ol>"},{"location":"methods/#error-handling","title":"Error Handling","text":"<p>Doxa uses a systematic approach to error handling through typed error unions:</p>"},{"location":"methods/#core-error-types","title":"Core Error Types","text":"<pre><code>// I/O related errors\nenum IOError {\n    FileNotFound,      // File does not exist\n    PermissionDenied,  // Insufficient permissions\n    DeviceError,       // Hardware/device failure\n    Interrupted,       // Operation interrupted\n    UnexpectedEOF,     // Premature end of file\n}\n\n// Path and filesystem errors\nenum PathError {\n    InvalidPath,      // Malformed path\n    NotFound,         // Path does not exist\n    AlreadyExists,    // Path already exists\n    IsDirectory,      // Expected file, got directory\n    NotDirectory,     // Expected directory, got file\n}\n\n// Runtime value error\nenum ValueError {\n    // Bounds and range errors\n    IndexOutOfRange,  // Array/string index outside valid range\n    EmptyCollection,  // Operation requires non-empty collection\n    InvalidRange,     // Invalid range specification (e.g., start &gt; end)\n\n    // Numeric errors\n    Overflow,         // Number exceeds type capacity\n    Underflow,        // Number below minimum value\n    DivideByZero,    // Division by zero\n\n    // Parse/format errors\n    ParseFailed,      // String-to-number parse failed (e.g., \"abc\" as int)\n    InvalidFormat,    // Invalid data format (e.g., malformed JSON)\n    InvalidEncoding,  // Invalid string encoding (e.g., invalid UTF-8)\n\n    // Collection errors\n    CapacityExceeded, // Collection would exceed max capacity\n    DuplicateKey,     // Duplicate key in map/set\n    KeyNotFound       // Key not found in map/set\n}\n\n// Resource errors\nenum ResourceError {\n    OutOfMemory,      // Memory allocation failed\n    TooLarge,         // Resource exceeds limits\n    Exhausted,        // Resource pool depleted\n}\n</code></pre>"},{"location":"methods/#method-error-types","title":"Method Error Types","text":"<p>Methods combine relevant errors into union types:</p> <pre><code>// Define specific error combinations for methods\n// Method-specific error types (runtime errors only)\nalias ArrayOpError =\n    | ValueError.EmptyCollection  // Array is empty\n    | ValueError.IndexOutOfRange  // Index out of bounds\n    | ValueError.CapacityExceeded // Can't grow array further\n    | ResourceError.OutOfMemory;  // System out of memory\n\nalias NumberParseError =\n    | ValueError.ParseFailed  // Invalid number format\n    | ValueError.Overflow     // Number too large\n    | ValueError.Underflow;   // Number too small\n\nalias ReadError =\n    | IOError.FileNotFound\n    | IOError.PermissionDenied\n    | PathError.InvalidPath;\n\nalias WriteError =\n    | IOError.PermissionDenied\n    | PathError.InvalidPath\n    | ResourceError.OutOfMemory;\n\n// Method signatures include error unions\nfunction @read(path :: string) returns(string | ReadError);\nfunction @write(path :: string, content :: string) returns(tetra | WriteError);\n</code></pre>"},{"location":"methods/#error-handling-examples","title":"Error Handling Examples","text":"<pre><code>// Using else for error handling\nvar content = @read(\"config.txt\") as string else {\n    @panic(\"Failed to read config\");\n};\n\n// Pattern matching on specific errors\nvar result = @write(\"log.txt\", \"Hello\") match {\n    true then \"Success\",\n    PermissionDenied then \"Permission denied\",\n    InvalidPath then \"Invalid path\",\n    else =&gt; \"Other error\"\n};\n\n// Composing error handling\nfunction readConfig() returns(string | ParseError) {\n    var raw = @read(\"config.txt\");\n    var rawString is raw as string else \"\";\n    return @parse(rawString);\n}\n</code></pre>"},{"location":"methods/#benefits","title":"Benefits","text":"<ol> <li>Type Safety: Errors are typed and checked at compile time</li> <li>Composability: Error types can be combined and transformed</li> <li>Clarity: Methods document their exact error cases</li> <li>Consistency: Common errors are reused across methods</li> <li>Flexibility: New error types can be added without breaking changes</li> </ol>"},{"location":"methods/#error-categories","title":"Error Categories","text":"<ul> <li>IOError: Input/output operations</li> <li> <p>PathError: File system paths</p> </li> <li> <p>ResourceError: System resource management</p> </li> <li>SecurityError: Permission and security</li> <li>ParseError: Data parsing and validation</li> <li>ExecError: Process execution</li> <li>NetworkError: Network operations</li> </ul> <p>Each built-in method documents its specific error types in its signature and documentation.</p>"},{"location":"soxa/","title":"SOXA File Format Specification","text":""},{"location":"soxa/#overview","title":"Overview","text":"<p>SOXA (Stacked Doxa) is Doxa's high level intermediate representation format. SOXA files contain compiled instructions that can be executed directly by the HIR VM without parsing overhead.</p>"},{"location":"soxa/#purpose","title":"Purpose","text":"<p>SOXA serves as an intermediate compilation target that enables:</p> <ul> <li>Direct execution of pre-compiled instructions</li> <li>Compilation result caching</li> <li>Platform-independent distribution of compiled programs</li> <li>Future native code generation via LLVM IR compilation</li> </ul>"},{"location":"soxa/#compilation-pipeline","title":"Compilation Pipeline","text":"<pre><code>Source Code (.doxa) \u2192 HIR Generation \u2192 SOXA File (.soxa) \u2192 VM Execution, LLVM IR generation\n</code></pre>"},{"location":"soxa/#file-format-structure","title":"File Format Structure","text":""},{"location":"soxa/#header-format","title":"Header Format","text":"<pre><code>Offset | Size | Field\n-------|------|-------\n0x00   | 4    | Magic Number (0x534F5841 \"SOXA\")\n0x04   | 2    | Version (0x0001)\n0x06   | 4    | Instruction Count\n0x0A   | 4    | Constant Count\n0x0E   | 4    | String Count\n0x12   | 4    | Function Count\n0x16   | 6    | Reserved (padding)\n</code></pre>"},{"location":"soxa/#data-sections","title":"Data Sections","text":"<ol> <li>Constant Pool - Serialized HIR values</li> <li>String Pool - Shared string literals</li> <li>Instruction Stream - HIR instructions with operands</li> <li>Function Table - Function metadata and entry points</li> </ol>"},{"location":"soxa/#hir-instruction-set","title":"HIR Instruction Set","text":""},{"location":"soxa/#stack-operations-tags-0-9-10","title":"Stack Operations (Tags 0, 9, 10)","text":"<ul> <li><code>Const</code> (0) - Push constant from constant pool onto stack</li> <li><code>Dup</code> (9) - Duplicate top stack value</li> <li><code>Pop</code> (10) - Remove top stack value</li> </ul>"},{"location":"soxa/#variable-operations-tags-1-2","title":"Variable Operations (Tags 1, 2)","text":"<ul> <li><code>LoadVar</code> (1) - Load variable by index and name with scope context</li> <li><code>StoreVar</code> (2) - Store top of stack to variable with scope management</li> </ul>"},{"location":"soxa/#arithmetic-operations-tags-3-4","title":"Arithmetic Operations (Tags 3, 4)","text":"<ul> <li><code>IntArith</code> (3) - Integer arithmetic (+, -, *, /, %) with overflow behavior</li> <li><code>FloatArith</code> - Floating-point arithmetic with exception handling</li> <li><code>Compare</code> (4) - Comparison operations (==, !=, &lt;, &gt;, &lt;=, &gt;=) with type info</li> </ul>"},{"location":"soxa/#control-flow-tags-5-6-7-8-11","title":"Control Flow (Tags 5, 6, 7, 8, 11)","text":"<ul> <li><code>Jump</code> (5) - Unconditional jump to label</li> <li><code>JumpCond</code> (6) - Conditional jump with true/false labels</li> <li><code>Call</code> (7) - Function call with CallKind resolution (LocalFunction, ModuleFunction, BuiltinFunction)</li> <li><code>Return</code> (8) - Return from function with optional value</li> <li><code>Label</code> (11) - Label marker for jump targets</li> </ul>"},{"location":"soxa/#scope-management-tags-21-22","title":"Scope Management (Tags 21, 22)","text":"<ul> <li><code>EnterScope</code> (21) - Enter new scope block with scope ID and variable count</li> <li><code>ExitScope</code> (22) - Exit scope block and cleanup variables</li> </ul>"},{"location":"soxa/#array-operations-tags-14-20","title":"Array Operations (Tags 14-20)","text":"<ul> <li><code>ArrayNew</code> (14) - Create new array with element type and initial size</li> <li><code>ArrayGet</code> (15) - Get element by index with optional bounds checking</li> <li><code>ArraySet</code> (16) - Set element by index with optional bounds checking</li> <li><code>ArrayPush</code> (17) - Append element with ResizeBehavior (Double, Fixed, Exact)</li> <li><code>ArrayPop</code> (18) - Remove last element</li> <li><code>ArrayLen</code> (19) - Get array length</li> <li><code>ArrayConcat</code> (20) - Concatenate two arrays</li> </ul>"},{"location":"soxa/#debug-operations-tags-12-13","title":"Debug Operations (Tags 12, 13)","text":"<ul> <li><code>Halt</code> (12) - Program termination</li> <li><code>Peek</code> (13) - Print/debug value with optional variable name</li> </ul>"},{"location":"soxa/#value-serialization","title":"Value Serialization","text":"<p>Values are encoded with type tags:</p> Tag Type Format 0 Integer 4-byte signed little-endian 1 Float 8-byte IEEE-754 double (bitcast as u64) 2 String 4-byte length + UTF-8 data 3 Boolean 1-byte (0=false, 1=true) 4 U8 1-byte unsigned 5 Nothing No data 6 Array 4-byte length + 4-byte capacity + 1-byte element type 7 Struct Struct instance (placeholder) 8 Tuple Tuple instance (placeholder) 9 Map Map instance (placeholder) 10 Enum Variant Enum variant (placeholder)"},{"location":"soxa/#call-kind-system","title":"Call Kind System","text":"<p>Function calls are tagged with their resolution type:</p> <pre><code>pub const CallKind = enum {\n    LocalFunction,    // User-defined function in current module\n    ModuleFunction,   // Function from imported module\n    BuiltinFunction,  // Built-in language functions (like array.push, array.length)\n};\n</code></pre> <p>Call instructions include:</p> <ul> <li>Function index for VM function table lookup</li> <li>Qualified name for LLVM function resolution</li> <li>Argument count for stack management</li> <li>Call kind for dispatch optimization</li> <li>Optional target module context</li> </ul>"},{"location":"soxa/#built-in-functions","title":"Built-in Functions","text":"<p>The VM provides built-in functions for core operations:</p> <ul> <li>Array Methods: <code>length()</code>, <code>push(element)</code>, <code>pop()</code>, array indexing</li> <li>String Methods: <code>length()</code>, concatenation, substring operations</li> <li>Debug Functions: <code>peek()</code> for value debugging</li> <li>Type Functions: <code>typeof()</code> for runtime type information</li> </ul> <p>Built-in functions are optimized with direct VM implementation rather than function calls.</p>"},{"location":"soxa/#usage","title":"Usage","text":""},{"location":"soxa/#build-integration","title":"Build Integration","text":"<pre><code>%.soxa: %.doxa\n    doxa compile $&lt; -o $@\n</code></pre>"},{"location":"soxa/#implementation-details","title":"Implementation Details","text":""},{"location":"soxa/#byte-order","title":"Byte Order","text":"<p>All multi-byte values use little-endian encoding.</p>"},{"location":"soxa/#version-compatibility","title":"Version Compatibility","text":"<ul> <li>Forward compatibility: newer versions read older SOXA files</li> <li>Unknown instruction tags trigger compilation fallback</li> <li>Version field enables format evolution</li> </ul>"},{"location":"soxa/#error-handling","title":"Error Handling","text":"<ul> <li>Magic number validation prevents loading invalid files</li> <li>Malformed SOXA files trigger source compilation fallback</li> <li>Unknown instructions generate runtime errors</li> </ul>"},{"location":"soxa/#array-serialization","title":"Array Serialization","text":"<p>Arrays serialize both length and capacity:</p> <ul> <li>Length: current number of elements (calculated by counting non-nothing elements)</li> <li>Capacity: allocated storage size for resize operations</li> <li>Element type: HIR type tag (Auto, Int, Float, String, Boolean, etc.)</li> <li>Elements: serialized element values (padded with HIRValue.nothing)</li> </ul> <p>Empty arrays receive minimum capacity allocation (8 elements) to enable growth.</p>"},{"location":"soxa/#array-resize-behavior","title":"Array Resize Behavior","text":"<p>The VM supports three resize strategies:</p> <ul> <li>Double: Double capacity when full (default for dynamic growth)</li> <li>Fixed: Error if capacity exceeded (for bounded collections)</li> <li>Exact: Only allocate exact amount needed (memory-optimized)</li> </ul>"},{"location":"soxa/#instruction-encoding","title":"Instruction Encoding","text":"<p>Instructions are encoded as:</p> <ol> <li>Instruction tag (1 byte)</li> <li>Operand data (variable length)</li> </ol>"},{"location":"soxa/#complete-instruction-format","title":"Complete Instruction Format","text":"Tag Instruction Format 0 Const [constant_id: 4 bytes] 1 LoadVar [var_index: 4 bytes] [name_length: 4 bytes] [name: variable] 2 StoreVar [var_index: 4 bytes] [name_length: 4 bytes] [name: variable] 3 IntArith [op: 1 byte] 4 Compare [op: 1 byte] 5 Jump [label_length: 4 bytes] [label: variable] 6 JumpCond [true_label_len: 4 bytes] [true_label: variable] [false_label_len: 4 bytes] [false_label: variable] 7 Call [function_index: 4 bytes] [arg_count: 4 bytes] [name_length: 4 bytes] [name: variable] [call_kind: 1 byte] 8 Return [has_value: 1 byte] 9 Dup (no operands) 10 Pop (no operands) 11 Label [name_length: 4 bytes] [name: variable] 12 Halt (no operands) 13 Peek [has_name: 1 byte] [name_length: 4 bytes if has_name] [name: variable if has_name] [value_type: 1 byte] 14 ArrayNew [element_type: 1 byte] [size: 4 bytes] 15 ArrayGet [bounds_check: 1 byte] 16 ArraySet [bounds_check: 1 byte] 17 ArrayPush [resize_behavior: 1 byte] 18 ArrayPop (no operands) 19 ArrayLen (no operands) 20 ArrayConcat (no operands) 21 EnterScope [scope_id: 4 bytes] [var_count: 4 bytes] 22 ExitScope [scope_id: 4 bytes]"},{"location":"soxa/#function-table-format","title":"Function Table Format","text":"<p>Each function entry contains:</p> <ul> <li>Function name (4-byte length + UTF-8 string)</li> <li>Parameter count (4 bytes)</li> <li>Return type (1 byte HIRType enum value)</li> <li>Start label (4-byte length + UTF-8 string)</li> <li>Local variable count (4 bytes)</li> <li>Is entry point flag (1 byte boolean)</li> </ul>"},{"location":"soxa/#constant-pool-format","title":"Constant Pool Format","text":"<p>Constants are serialized sequentially using the value serialization format. The constant pool enables:</p> <ul> <li>Deduplication of identical values</li> <li>Efficient loading of large literals</li> <li>Type information preservation</li> </ul>"},{"location":"soxa/#string-pool-format","title":"String Pool Format","text":"<p>Strings are stored once and referenced by index. String pool entries contain:</p> <ul> <li>String length (4 bytes)</li> <li>UTF-8 encoded string data</li> </ul>"},{"location":"soxa/#debug-information","title":"Debug Information","text":"<p>Debug information (when present) includes:</p> <ul> <li>Source file mapping</li> <li>Line number information</li> <li>Variable name preservation</li> <li>Type information for peekion</li> </ul>"},{"location":"soxa/#file-size-characteristics","title":"File Size Characteristics","text":"<p>Typical SOXA files are 60-80% the size of equivalent source code due to:</p> <ul> <li>Binary encoding efficiency</li> <li>Constant pool deduplication</li> <li>Elimination of whitespace and comments</li> <li>Compact instruction representation</li> </ul>"},{"location":"soxa/#vm-execution-engine","title":"VM Execution Engine","text":"<p>The HIR VM executes SOXA files directly with these components:</p>"},{"location":"soxa/#execution-state","title":"Execution State","text":"<ul> <li>Instruction pointer (IP) indexing into instruction array</li> <li>Heap-allocated HIRStack (1MB) to avoid system stack overflow</li> <li>CallStack for function call management with return address tracking</li> <li>ScopeManager integration for variable isolation in recursive calls</li> </ul>"},{"location":"soxa/#performance-optimizations","title":"Performance Optimizations","text":"<ul> <li>Fast Mode: Variable caching and reduced debug output for computational workloads</li> <li>Turbo Mode: Hot variable cache with direct storage lookup (4-slot cache)</li> <li>Label Pre-resolution: All labels resolved to instruction indices at startup (O(1) jumps)</li> <li>Scope Isolation: Each function call gets isolated variable scope for recursion safety</li> </ul>"},{"location":"soxa/#memory-management","title":"Memory Management","text":"<ul> <li>Integration with existing MemoryManager and ScopeManager</li> <li>Automatic scope creation/cleanup for function calls</li> <li>Variable storage deduplication and hot caching</li> <li>Proper cleanup on VM shutdown</li> </ul>"},{"location":"soxa/#execution-flow","title":"Execution Flow","text":"<ol> <li>Pre-resolve all labels to instruction indices</li> <li>Execute instructions in linear sequence</li> <li>Handle jumps via pre-resolved label map</li> <li>Manage function calls with isolated scopes</li> <li>Clean up scopes and memory on return/exit</li> </ol>"},{"location":"soxa/#validation","title":"Validation","text":"<p>SOXA files undergo validation during loading:</p> <ol> <li>Magic number verification (0x534F5841 \"SOXA\")</li> <li>Version compatibility check (version 1)</li> <li>Section size validation</li> <li>Instruction stream integrity</li> <li>Constant pool consistency</li> <li>Function table validation</li> </ol> <p>Invalid files trigger fallback to source compilation.</p>"},{"location":"syntax/","title":"Doxa Language Reference","text":""},{"location":"syntax/#core-language-features","title":"Core Language Features","text":""},{"location":"syntax/#primitive-types","title":"Primitive Types","text":"<p>Types in Doxa are grouped in three ways, atomic, molecular, and meta. All together there are 14 of these primitive types to represent data in Doxa.</p>"},{"location":"syntax/#atomic","title":"Atomic","text":"<p>Atomic types are the most basic units of data. Currently Doxa has 3 default number types, with plans for optional dynamic number sizing in the future.</p> <p>int - i32 float - f64 byte - u8 hex literal string tetra - logical value, see page on tetras for more info nothing - empty type</p>"},{"location":"syntax/#molecular","title":"Molecular","text":"<p>Molecular types are constructed out of atomic types. They are</p> <p>array - must be homogenous struct - no classes, no inheretance, only composition enum map function - user functions, library functions, etc union - can be handled with the collapse operator, see page on unions for more info</p>"},{"location":"syntax/#basic-composition-example","title":"Basic Composition Example","text":"<pre><code>struct Animal {\n    name: string\n}\n\nstruct Dog {\n    // Composition instead of inheritance\n    animal: Animal,\n    breed: string,\n\n    fn bark(self) {\n        print(animal.name + \" says woof!\");\n    }\n}\n\nvar dog is Dog {\n    animal: Animal {\n        name: \"Spot\"\n        },\n    breed: \"Labrador\"\n};\n</code></pre> <p>&lt;!-- ### Modules</p> <pre><code>// math.doxa\nexport fn add(a :: int, b :: int) -&gt; int {\n    return a + b;\n}\n\n// main.doxa\nimport { add } from \"./math.doxa\";\nvar sum is add(1, 2);\n``` --&gt;\n\n## Data Types\n\n### Basic Types\n\nStandard types include:\n\n- `int`: Integer numbers\n- `float`: Floating point numbers\n- `string`: Text strings\n- `tetra`: Four-valued logic system\n\nThe `tetra` type represents a four cornered value with the possible states: `true`, `false`, `both`, and `neither`. For additional information see the tetra page.\n\n````\n\n### Arrays\n\nArrays are homogeneous collections with type inference:\n\n```doxa\nvar nums :: int[] is [1, 2, 3];    // Explicit typing\nvar strs is [\"a\", \"b\"];            // Inferred as string[]\n\n// Invalid operations\nvar mixed is [1, \"two\", true];     // Error: mixed types\nnums.push(\"four\");                // Error: type mismatch\n````\n\n### Tuples\n\nFixed-size collections supporting heterogenus types:\n\n```doxa\nvar point is (: 10, \"hello\", true :);         // Simple tuple\nvar nested is (: (: 1, \"hello\" :), (: 3, true :) :);    // Nested tuple\n\npoint[0];                         // Access first element\nnested[1][0];                     // Access nested element\n</code></pre>"},{"location":"syntax/#maps","title":"Maps","text":"<p>String-keyed dictionaries:</p> <pre><code>var scores is {\n    \"alice\": 100,\n    \"bob\": 85\n};\nscores[\"alice\"];                  // Access value\n</code></pre>"},{"location":"syntax/#control-flow","title":"Control Flow","text":""},{"location":"syntax/#pattern-matching","title":"Pattern Matching","text":"<pre><code>enum Status { Success, Error, Pending }\n\nvar result is match status {\n    .Success =&gt; \"all good\",\n    .Error =&gt; \"failed\",\n    else =&gt; \"waiting\"\n};\n</code></pre> <p>Warning</p> <p>Match expressions must be exhaustive or include an <code>else</code> clause.</p>"},{"location":"syntax/#error-handling","title":"Error Handling","text":"<pre><code>try {\n    riskyOperation();\n} catch {\n    handleError();\n}\n</code></pre>"},{"location":"syntax/#special-operators","title":"Special Operators","text":""},{"location":"syntax/#peek-operator","title":"Peek operator (<code>?</code>)","text":"<pre><code>var x is computeValue();\nx?;                              // Prints value with location, name, and type\n</code></pre>"},{"location":"syntax/#type-information","title":"Type Information","text":"<pre><code>typeof(42);                      // \"int\"\ntypeof(\"hello\");                 // \"string\"\ntypeof([1,2,3]);                 // \"array\"\n</code></pre>"},{"location":"syntax/#collection-quantifiers","title":"Collection Quantifiers","text":"<pre><code>(\u2203x \u2208 numbers : x &gt; 10) // Logical notation\n(exists x in numbers where x &gt; 10) // English prose\n(\u2200x \u2208 numbers : x &gt; 0) // Logical notation\n(forall x in numbers where x &gt; 0) // English prose\n</code></pre>"},{"location":"syntax/#conditional-expressions","title":"Conditional Expressions","text":"<p>All conditionals are expressions and return values:</p> <pre><code>var result is if condition then {\n    value1\n} else {\n    value2\n};\n</code></pre> <p>Note</p> <p>Expressions without a value return <code>nothing</code>: <code>doxa     var x is if (false) { y is 1 };  // x becomes nothing</code></p>"},{"location":"syntax/#function-return-types","title":"Function Return Types","text":"<p>Functions can specify return types using either <code>-&gt;</code> or <code>returns</code> syntax:</p> <pre><code>fn add(a: int, b: int) -&gt; int {\n    return a + b;\n}\n\n// Alternative syntax\nfn add(a: int, b: int) returns(int) {\n    return a + b;\n}\n</code></pre> <p>return types are optional and inferred by default:</p> <pre><code>// Normal Mode - Valid\nfn add(a, b) {\n    return a + b;\n}\n</code></pre>"},{"location":"syntax/#logic","title":"Logic","text":""},{"location":"syntax/#first-order-logic","title":"First order logic","text":"<p>First order logic always produces a true or false value. For more information on tetras see the tetra page.</p> <p>Doxa has extensive for traditional first order logics that work as expected with true and false values. These can be represented in formal unicode notation:</p> <pre><code>const arr :: int[] = [1, 2, 3, 4, 5]\n\n// existential quantifier \u2203, element of \u2208\n\u2203x \u2208 arr : x &gt; 3; // true\n\n// universal quantifier \u2200, where :\n\u2200x \u2208 arr : x &gt; 3; // false\n\n// NOT \u00ac\n\u00acfalse; // true\n\n// biconditional \u2194\nfalse \u2194 false; // true\n\n// XOR \u2295\ntrue \u2295 true; // false\n\n// AND \u2227\ntrue \u2227 false; // false\n\n// OR \u2228\ntrue \u2228 false; // true\n\n// NAND \u2191\ntrue \u2191 false; // true\n\n// NOR \u2193\ntrue \u2193 false; // false\n\n// implication \u2192\ntrue \u2192 false; // false\n</code></pre> <p>This unicode support is paired with plaintext keywords which act in an identical fashion:</p> <pre><code>\u2203 - exists\n\u2200 - forall\n\u2208 - in\n: - where\n\u00ac - not\n\u2194 - iff\n\u2295 - xor\n\u2227 - and\n\u2228 - or\n\u2191 - nand\n\u2193 - nor\n\u2192 - implies\n</code></pre> <p>This means formal logical representation can be written in either way:</p> <pre><code>const arr :: int[] = [1, 2, 3, 4, 5]\n\n\u00ac(\u2200x \u2208 arr : x &gt; 3); // true\nnot (forall x in arr where x &gt; 3); // true\n</code></pre>"},{"location":"syntax/#trancendental-logic","title":"Trancendental logic","text":"<p>There are currently two trancendental operators, <code>and</code> and <code>not</code>. These can be represented by the following truth tables:</p> ^ T F B N F F B B N T B T B N B B B B N N N N N N ~ F T T F B N N B"},{"location":"tetras/","title":"Doxa Language Reference","text":""},{"location":"tetras/#tetras","title":"Tetras","text":""},{"location":"tetras/#type-overview","title":"Type overview","text":"<p>A tetra is a type which represents four cornered logic as opposed to Booles binary logic. You can think of a tetra a bit like an extended boolean type. Where bools can only exist in only two states, true or false, tetras can exist in four. The four states which tetras can exist in are:</p> <p><code>true</code> - These first two values should be familiar <code>false</code> <code>both</code> - This is equivilant to both true and false <code>neither</code> - This is equivilatnt neither to true or false</p>"},{"location":"tetras/#an-example","title":"An Example","text":"<p>Let's start with a condition, in this case, the condition of being alive. In traditional boolean logic there would be only two states for this condition, true or false, or in term of the condition, alive or dead. But a tetra can represent logical conditions outside of this true/false, alive/dead binary.</p> <p>Here are four values to represent the four possible states or corners of a tetra:</p> <pre><code>const Bob is true;\nconst Shakespere is false;\nconst zombie is both;\nconst angel is neither;\n</code></pre> <p>Now let's create some conditional logic to understand how a tetra works. Here is a function to discover whether something is alive or not:</p> <pre><code>function living(alive :: tetra) {\n    if alive then \"I am alive\"?;\n    if not alive then \"I am dead\"?;\n}\n</code></pre> <p>Notice that if this function was in another language and was using a boolean, there would only be two possible branches when executed. If you would like to follow along, here is how I ran the values through the function:</p> <pre><code>\"Bob\"?;\nliving(Bob);\n\"Shakespere\"?;\nliving(Shakespere);\n\"zombie\"?;\nliving(zombie);\n\"angel\"?;\nliving(angel);\n</code></pre> <p>And here is the ouput I received:</p> <pre><code>[C:\\dev\\zig\\doxa\\test.doxa:11:6] value = \"Bob\"\n[C:\\dev\\zig\\doxa\\test.doxa:7:31] value = \"I am alive\"\n[C:\\dev\\zig\\doxa\\test.doxa:13:13] value = \"Shakespere\"\n[C:\\dev\\zig\\doxa\\test.doxa:8:34] value = \"I am dead\"\n[C:\\dev\\zig\\doxa\\test.doxa:15:9] value = \"zombie\"\n[C:\\dev\\zig\\doxa\\test.doxa:7:31] value = \"I am alive\"\n[C:\\dev\\zig\\doxa\\test.doxa:8:34] value = \"I am dead\"\n[C:\\dev\\zig\\doxa\\test.doxa:17:8] value = \"angel\"\n</code></pre> <p>The output here might seems strange but the logic behind it is very simple. True only triggers conditions which are true. False only triggers conditions which are false. Both will trigger both the condition regardless if it is true or false. Neither will never trigger a condition.</p> <p>This means zombie triggers both the <code>alive</code> condition and its negation <code>not alive</code>.</p> <pre><code>[C:\\dev\\zig\\doxa\\test.doxa:15:9] value = \"zombie\"\n[C:\\dev\\zig\\doxa\\test.doxa:7:31] value = \"I am alive\"\n[C:\\dev\\zig\\doxa\\test.doxa:8:34] value = \"I am dead\"\n</code></pre> <p>Angel triggers neither and so we see no output from either branch.</p> <pre><code>[C:\\dev\\zig\\doxa\\test.doxa:17:8] value = \"angel\"\n</code></pre> <p>Keep in mind, a tetra is a value. It doesn't actually alter the logic flow of your program, it's purpose is simply to follow the logic flow in ways basic true and false cannot.</p> <p>Special attention should (not) be paid to the else clause. The else clause is exactly what it sounds like - \"if a condition is ment, then do x, OR ELSE, do y\". As we now know, both will always trigger a condition, and neither will never trigger a condition. The effect with else blocks is then as you would assume, both with never trigger an else clause, and neither will always trigger an else clause.</p> <pre><code>const zombie is both;\nconst angel is neither;\n\nfunction living(alive :: tetra) {\n    if alive then \"I am alive\"? else \"I am not alive\"?;\n    if not alive then \"I am dead\"? else \"I am not dead\"?;\n}\n\n\"zombie\"?;\nliving(zombie);\n\"angel\"?;\nliving(angel);\n</code></pre> <pre><code>[C:\\dev\\zig\\doxa\\test.doxa:9:9] value = \"zombie\"\n[C:\\dev\\zig\\doxa\\test.doxa:5:31] value = \"I am alive\"\n[C:\\dev\\zig\\doxa\\test.doxa:6:34] value = \"I am dead\"\n[C:\\dev\\zig\\doxa\\test.doxa:11:8] value = \"angel\"\n[C:\\dev\\zig\\doxa\\test.doxa:5:55] value = \"I am not alive\"\n[C:\\dev\\zig\\doxa\\test.doxa:6:57] value = \"I am not dead\"\n</code></pre>"},{"location":"unions/","title":"Typed Unions","text":""},{"location":"unions/#what-are-unions","title":"What are unions","text":"<p>Unions are a special type which can represent one type or another. For instance, you can make a value that either returns a number, or a string. A union can only hold a single value, and therefore represent a single type when used.</p>"},{"location":"unions/#syntax","title":"Syntax","text":"<p>Unions are declared using pipes:</p> <pre><code>var x :: int | float;\nvar y :: string | int | float;\n</code></pre> <p>The pipe's only usage in Doxa is to specify a typed union.</p>"},{"location":"unions/#examples","title":"Examples","text":"<pre><code>// A union that can be either an integer or a float\nvar number :: int | float;\nnumber is 42;     // Valid - integer\nnumber is 3.14;   // Valid - float\n\n// A union that can be a string, integer, or float\nvar value :: string | int | float;\nvalue is \"hello\"; // Valid - string\nvalue is 100;     // Valid - integer\nvalue is 2.718;   // Valid - float\n\n// Unions default to the first type when not initialized\nvar defaulted :: int | float;\ndefaulted?;       // Prints 0 (default int value)\n\nvar float_first :: float | int;\nfloat_first?;     // Prints 0.0 (default float value)\n</code></pre>"},{"location":"unions/#default-behavior","title":"Default Behavior","text":"<p>When a union is declared without initialization, it defaults to the first type in the union with its default value:</p> <ul> <li><code>int</code> defaults to <code>0</code></li> <li><code>float</code> defaults to <code>0.0</code></li> <li><code>byte</code> defaults to <code>0x00</code></li> <li><code>string</code> defaults to <code>\"\"</code></li> <li><code>tetra</code> defaults to <code>false</code></li> <li><code>nothing</code> defaults to <code>nothing</code></li> </ul> <p>This ensures that unions always have a well-defined state and the compiler knows which type is currently active.</p>"},{"location":"unions/#optional-values","title":"Optional Values","text":"<p>A common use case for unions is representing optional values using <code>nothing</code>:</p> <pre><code>// Optional integer\nvar maybe_name :: string | nothing;\nmaybe_name is \"Alice\";     // Has a value\nmaybe_name is nothing; // No value\n\n// Function that might not return a value\nfunction findValue(arr :: MyObject[], target :: string) returns(int | nothing) {\n    each x in arr {\n        if (x.name equals target) then {\n            return x;\n        }\n    }\n    return nothing; // Not found\n}\n</code></pre>"},{"location":"unions/#why-unions-are-useful","title":"Why unions are useful","text":"<p>Unions are particularly useful when:</p> <ul> <li>A function can return different types depending on the input</li> <li>A variable needs to hold different types at different times</li> <li>You want to represent optional values (like <code>T | nothing</code>)</li> <li>You're working with data that can have multiple valid representations</li> </ul>"},{"location":"unions/#error-handling","title":"Error Handling","text":"<p>Here is a robust example of how error handling can be done using Doxa. Note that none of this handling is specific to errors, it is a general return pattern which relies on normal values making semanitcs extremely clear and flexible. This relies on the <code>as</code> keyword which attempts to narrow a value into another type.</p> <pre><code>enum ErrorList {\n    Overflow,\n    Underflow,\n}\n\n// Match function to process errors\nfunction handleError(err :: ErrorList) {\n    match err {\n        .Overflow =&gt; doSomething(),\n        .Underflow =&gt; doSomethingElse(),\n    };\n}\n\n// Function returns a union - we won't know if the value is a number or one of our errors until we check\nfunction addLimit(a :: int, b :: int) returns( int | ErrorList ) {\n    const result is a + b;\n    if result &gt; 255 then return ErrorList.Overflow;\n    if result &lt; 0 then return ErrorList.Underflow;\n    return result;\n}\n\n// All of these return unions\nconst unknownBigResult is addLimit(1000, 1000);   // ErrorList.Overflow\nconst unknownSmallResult is addLimit(100, -1000); // ErrorList.Underflow\nconst unknownRightResult is addLimit(100, -10);   // 90\n\n// Handle errors - several approaches:\n\n// Approach 1: Pattern matching (cleanest)\nmatch unknownRightResult {\n    int =&gt; onlyUsesInts(unknownRightResult),  // unknownRightResult is typed as int here\n    ErrorList =&gt; handleError(unknownRightResult),  // unknownRightResult is typed as ErrorList here\n}\n\n// Approach 2: Explicit fallback with error handling\nconst myInt = unknownRightResult as int else {\n    @panic(\"This should never happen in production!\");\n};\nonlyUsesInts(myInt);\n\n// Note type checking in control flow doesn't implicitly cast unlike match case which is exhaustive\n// this can be done by casting bt it is not as ergonomic as match case\nif unknownRightResult @istype int then {\n    onlyUsesInts(unknownRightResult) as int else{};\n} else if unknownRightResult @istype ErrorList then {\n    handleError(unknownRightResult) as ErrorList else{};\n}\n</code></pre>"},{"location":"unions/#type-casting-with-as","title":"Type Casting with <code>as</code>","text":"<p>The <code>as</code> keyword attempts to cast a union to a specific type. If the cast fails, the <code>else</code> block is executed:</p> <pre><code>var value :: int | string;\nvalue is \"hello\";\n\n// This will execute the else block since value is currently a string\nconst number = value as int else {\n    return error.ExpectedInteger;\n};\n\n// This will succeed since value is now an int\nvalue is 42;\nconst doubled = value as int else {\n    return error.ExpectedInteger;\n}; // doubled is 84\n</code></pre>"},{"location":"unions/#common-patterns","title":"Common Patterns","text":"<p>Safe extraction with default:</p> <pre><code>const result = someUnion as int else {\n    return 0; // Default value if not an int\n};\n</code></pre> <p>Error handling:</p> <pre><code>const number = value as int else {\n    @panic(\"This should never happen in production!\");\n};\n</code></pre> <p>Conditional processing:</p> <pre><code>const processed = value as string else {\n    // Handle non-string case\n    return \"default\";\n};\n</code></pre> <p>The <code>as</code> keyword is essential for safely working with unions when you need to extract a specific type.</p>"}]}