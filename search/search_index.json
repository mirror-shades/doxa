{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Doxa","text":"<pre><code>Everything is real and is not real,\nBoth real and not real,\nNeither real nor not real.\nThis is Lord Buddha\u2019s teaching.\n\n- N\u0101g\u0101rjuna\n    Verses on the Middle Way (2nd\u20133rd century CE)\n</code></pre> <p>Doxa is a simple to write, highly readible language based on four corned logic inspired by the logic of Nagarjuna. In Doxa there are no booleans. Doxa instead uses a four cournered logical unit called a tetra. Tetras can represent true and false, which act as you would expect them to in a traditional programing language.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Language Syntax - Complete language reference</li> <li>Tetras - Four-cornered logic system</li> <li>SOXA Format - Binary intermediate representation and execution format</li> </ul>"},{"location":"soxa/","title":"SOXA File Format Specification","text":""},{"location":"soxa/#overview","title":"Overview","text":"<p>SOXA (Stacked Doxa) is Doxa's high level intermediate representation format. SOXA files contain compiled instructions that can be executed directly by the HIR VM without parsing overhead.</p>"},{"location":"soxa/#purpose","title":"Purpose","text":"<p>SOXA serves as an intermediate compilation target that enables:</p> <ul> <li>Direct execution of pre-compiled instructions</li> <li>Compilation result caching</li> <li>Platform-independent distribution of compiled programs</li> <li>Future native code generation via LLVM IR compilation</li> </ul>"},{"location":"soxa/#compilation-pipeline","title":"Compilation Pipeline","text":"<pre><code>Source Code (.doxa) \u2192 HIR Generation \u2192 SOXA File (.soxa) \u2192 VM Execution, LLVM IR generation\n</code></pre>"},{"location":"soxa/#file-format-structure","title":"File Format Structure","text":""},{"location":"soxa/#header-format","title":"Header Format","text":"<pre><code>Offset | Size | Field\n-------|------|-------\n0x00   | 4    | Magic Number (0x534F5841 \"SOXA\")\n0x04   | 2    | Version (0x0001)\n0x06   | 4    | Instruction Count\n0x0A   | 4    | Constant Count\n0x0E   | 4    | String Count\n0x12   | 4    | Function Count\n0x16   | 6    | Reserved (padding)\n</code></pre>"},{"location":"soxa/#data-sections","title":"Data Sections","text":"<ol> <li>Constant Pool - Serialized HIR values</li> <li>String Pool - Shared string literals</li> <li>Instruction Stream - HIR instructions with operands</li> <li>Function Table - Function metadata and entry points</li> </ol>"},{"location":"soxa/#hir-instruction-set","title":"HIR Instruction Set","text":""},{"location":"soxa/#stack-operations-tags-0-9-10","title":"Stack Operations (Tags 0, 9, 10)","text":"<ul> <li><code>Const</code> (0) - Push constant from constant pool onto stack</li> <li><code>Dup</code> (9) - Duplicate top stack value</li> <li><code>Pop</code> (10) - Remove top stack value</li> </ul>"},{"location":"soxa/#variable-operations-tags-1-2","title":"Variable Operations (Tags 1, 2)","text":"<ul> <li><code>LoadVar</code> (1) - Load variable by index and name with scope context</li> <li><code>StoreVar</code> (2) - Store top of stack to variable with scope management</li> </ul>"},{"location":"soxa/#arithmetic-operations-tags-3-4","title":"Arithmetic Operations (Tags 3, 4)","text":"<ul> <li><code>IntArith</code> (3) - Integer arithmetic (+, -, *, /, %) with overflow behavior</li> <li><code>FloatArith</code> - Floating-point arithmetic with exception handling</li> <li><code>Compare</code> (4) - Comparison operations (==, !=, &lt;, &gt;, &lt;=, &gt;=) with type info</li> </ul>"},{"location":"soxa/#control-flow-tags-5-6-7-8-11","title":"Control Flow (Tags 5, 6, 7, 8, 11)","text":"<ul> <li><code>Jump</code> (5) - Unconditional jump to label</li> <li><code>JumpCond</code> (6) - Conditional jump with true/false labels</li> <li><code>Call</code> (7) - Function call with CallKind resolution (LocalFunction, ModuleFunction, BuiltinFunction)</li> <li><code>Return</code> (8) - Return from function with optional value</li> <li><code>Label</code> (11) - Label marker for jump targets</li> </ul>"},{"location":"soxa/#scope-management-tags-21-22","title":"Scope Management (Tags 21, 22)","text":"<ul> <li><code>EnterScope</code> (21) - Enter new scope block with scope ID and variable count</li> <li><code>ExitScope</code> (22) - Exit scope block and cleanup variables</li> </ul>"},{"location":"soxa/#array-operations-tags-14-20","title":"Array Operations (Tags 14-20)","text":"<ul> <li><code>ArrayNew</code> (14) - Create new array with element type and initial size</li> <li><code>ArrayGet</code> (15) - Get element by index with optional bounds checking</li> <li><code>ArraySet</code> (16) - Set element by index with optional bounds checking</li> <li><code>ArrayPush</code> (17) - Append element with ResizeBehavior (Double, Fixed, Exact)</li> <li><code>ArrayPop</code> (18) - Remove last element</li> <li><code>ArrayLen</code> (19) - Get array length</li> <li><code>ArrayConcat</code> (20) - Concatenate two arrays</li> </ul>"},{"location":"soxa/#debug-operations-tags-12-13","title":"Debug Operations (Tags 12, 13)","text":"<ul> <li><code>Halt</code> (12) - Program termination</li> <li><code>Peek</code> (13) - Print/debug value with optional variable name</li> </ul>"},{"location":"soxa/#value-serialization","title":"Value Serialization","text":"<p>Values are encoded with type tags:</p> Tag Type Format 0 Integer 4-byte signed little-endian 1 Float 8-byte IEEE-754 double (bitcast as u64) 2 String 4-byte length + UTF-8 data 3 Boolean 1-byte (0=false, 1=true) 4 U8 1-byte unsigned 5 Nothing No data 6 Array 4-byte length + 4-byte capacity + 1-byte element type 7 Struct Struct instance (placeholder) 8 Tuple Tuple instance (placeholder) 9 Map Map instance (placeholder) 10 Enum Variant Enum variant (placeholder)"},{"location":"soxa/#call-kind-system","title":"Call Kind System","text":"<p>Function calls are tagged with their resolution type:</p> <pre><code>pub const CallKind = enum {\n    LocalFunction,    // User-defined function in current module\n    ModuleFunction,   // Function from imported module\n    BuiltinFunction,  // Built-in language functions (like array.push, array.length)\n};\n</code></pre> <p>Call instructions include:</p> <ul> <li>Function index for VM function table lookup</li> <li>Qualified name for LLVM function resolution</li> <li>Argument count for stack management</li> <li>Call kind for dispatch optimization</li> <li>Optional target module context</li> </ul>"},{"location":"soxa/#built-in-functions","title":"Built-in Functions","text":"<p>The VM provides built-in functions for core operations:</p> <ul> <li>Array Methods: <code>length()</code>, <code>push(element)</code>, <code>pop()</code>, array indexing</li> <li>String Methods: <code>length()</code>, concatenation, substring operations</li> <li>Debug Functions: <code>peek()</code> for value debugging</li> <li>Type Functions: <code>typeof()</code> for runtime type information</li> </ul> <p>Built-in functions are optimized with direct VM implementation rather than function calls.</p>"},{"location":"soxa/#usage","title":"Usage","text":""},{"location":"soxa/#build-integration","title":"Build Integration","text":"<pre><code>%.soxa: %.doxa\n    doxa compile $&lt; -o $@\n</code></pre>"},{"location":"soxa/#implementation-details","title":"Implementation Details","text":""},{"location":"soxa/#byte-order","title":"Byte Order","text":"<p>All multi-byte values use little-endian encoding.</p>"},{"location":"soxa/#version-compatibility","title":"Version Compatibility","text":"<ul> <li>Forward compatibility: newer versions read older SOXA files</li> <li>Unknown instruction tags trigger compilation fallback</li> <li>Version field enables format evolution</li> </ul>"},{"location":"soxa/#error-handling","title":"Error Handling","text":"<ul> <li>Magic number validation prevents loading invalid files</li> <li>Malformed SOXA files trigger source compilation fallback</li> <li>Unknown instructions generate runtime errors</li> </ul>"},{"location":"soxa/#array-serialization","title":"Array Serialization","text":"<p>Arrays serialize both length and capacity:</p> <ul> <li>Length: current number of elements (calculated by counting non-nothing elements)</li> <li>Capacity: allocated storage size for resize operations</li> <li>Element type: HIR type tag (Auto, Int, Float, String, Boolean, etc.)</li> <li>Elements: serialized element values (padded with HIRValue.nothing)</li> </ul> <p>Empty arrays receive minimum capacity allocation (8 elements) to enable growth.</p>"},{"location":"soxa/#array-resize-behavior","title":"Array Resize Behavior","text":"<p>The VM supports three resize strategies:</p> <ul> <li>Double: Double capacity when full (default for dynamic growth)</li> <li>Fixed: Error if capacity exceeded (for bounded collections)</li> <li>Exact: Only allocate exact amount needed (memory-optimized)</li> </ul>"},{"location":"soxa/#instruction-encoding","title":"Instruction Encoding","text":"<p>Instructions are encoded as:</p> <ol> <li>Instruction tag (1 byte)</li> <li>Operand data (variable length)</li> </ol>"},{"location":"soxa/#complete-instruction-format","title":"Complete Instruction Format","text":"Tag Instruction Format 0 Const [constant_id: 4 bytes] 1 LoadVar [var_index: 4 bytes] [name_length: 4 bytes] [name: variable] 2 StoreVar [var_index: 4 bytes] [name_length: 4 bytes] [name: variable] 3 IntArith [op: 1 byte] 4 Compare [op: 1 byte] 5 Jump [label_length: 4 bytes] [label: variable] 6 JumpCond [true_label_len: 4 bytes] [true_label: variable] [false_label_len: 4 bytes] [false_label: variable] 7 Call [function_index: 4 bytes] [arg_count: 4 bytes] [name_length: 4 bytes] [name: variable] [call_kind: 1 byte] 8 Return [has_value: 1 byte] 9 Dup (no operands) 10 Pop (no operands) 11 Label [name_length: 4 bytes] [name: variable] 12 Halt (no operands) 13 Peek [has_name: 1 byte] [name_length: 4 bytes if has_name] [name: variable if has_name] [value_type: 1 byte] 14 ArrayNew [element_type: 1 byte] [size: 4 bytes] 15 ArrayGet [bounds_check: 1 byte] 16 ArraySet [bounds_check: 1 byte] 17 ArrayPush [resize_behavior: 1 byte] 18 ArrayPop (no operands) 19 ArrayLen (no operands) 20 ArrayConcat (no operands) 21 EnterScope [scope_id: 4 bytes] [var_count: 4 bytes] 22 ExitScope [scope_id: 4 bytes]"},{"location":"soxa/#function-table-format","title":"Function Table Format","text":"<p>Each function entry contains:</p> <ul> <li>Function name (4-byte length + UTF-8 string)</li> <li>Parameter count (4 bytes)</li> <li>Return type (1 byte HIRType enum value)</li> <li>Start label (4-byte length + UTF-8 string)</li> <li>Local variable count (4 bytes)</li> <li>Is entry point flag (1 byte boolean)</li> </ul>"},{"location":"soxa/#constant-pool-format","title":"Constant Pool Format","text":"<p>Constants are serialized sequentially using the value serialization format. The constant pool enables:</p> <ul> <li>Deduplication of identical values</li> <li>Efficient loading of large literals</li> <li>Type information preservation</li> </ul>"},{"location":"soxa/#string-pool-format","title":"String Pool Format","text":"<p>Strings are stored once and referenced by index. String pool entries contain:</p> <ul> <li>String length (4 bytes)</li> <li>UTF-8 encoded string data</li> </ul>"},{"location":"soxa/#debug-information","title":"Debug Information","text":"<p>Debug information (when present) includes:</p> <ul> <li>Source file mapping</li> <li>Line number information</li> <li>Variable name preservation</li> <li>Type information for peekion</li> </ul>"},{"location":"soxa/#file-size-characteristics","title":"File Size Characteristics","text":"<p>Typical SOXA files are 60-80% the size of equivalent source code due to:</p> <ul> <li>Binary encoding efficiency</li> <li>Constant pool deduplication</li> <li>Elimination of whitespace and comments</li> <li>Compact instruction representation</li> </ul>"},{"location":"soxa/#vm-execution-engine","title":"VM Execution Engine","text":"<p>The HIR VM executes SOXA files directly with these components:</p>"},{"location":"soxa/#execution-state","title":"Execution State","text":"<ul> <li>Instruction pointer (IP) indexing into instruction array</li> <li>Heap-allocated HIRStack (1MB) to avoid system stack overflow</li> <li>CallStack for function call management with return address tracking</li> <li>ScopeManager integration for variable isolation in recursive calls</li> </ul>"},{"location":"soxa/#performance-optimizations","title":"Performance Optimizations","text":"<ul> <li>Fast Mode: Variable caching and reduced debug output for computational workloads</li> <li>Turbo Mode: Hot variable cache with direct storage lookup (4-slot cache)</li> <li>Label Pre-resolution: All labels resolved to instruction indices at startup (O(1) jumps)</li> <li>Scope Isolation: Each function call gets isolated variable scope for recursion safety</li> </ul>"},{"location":"soxa/#memory-management","title":"Memory Management","text":"<ul> <li>Integration with existing MemoryManager and ScopeManager</li> <li>Automatic scope creation/cleanup for function calls</li> <li>Variable storage deduplication and hot caching</li> <li>Proper cleanup on VM shutdown</li> </ul>"},{"location":"soxa/#execution-flow","title":"Execution Flow","text":"<ol> <li>Pre-resolve all labels to instruction indices</li> <li>Execute instructions in linear sequence</li> <li>Handle jumps via pre-resolved label map</li> <li>Manage function calls with isolated scopes</li> <li>Clean up scopes and memory on return/exit</li> </ol>"},{"location":"soxa/#validation","title":"Validation","text":"<p>SOXA files undergo validation during loading:</p> <ol> <li>Magic number verification (0x534F5841 \"SOXA\")</li> <li>Version compatibility check (version 1)</li> <li>Section size validation</li> <li>Instruction stream integrity</li> <li>Constant pool consistency</li> <li>Function table validation</li> </ol> <p>Invalid files trigger fallback to source compilation.</p>"},{"location":"syntax/","title":"Doxa Language Reference","text":""},{"location":"syntax/#core-language-features","title":"Core Language Features","text":""},{"location":"syntax/#basic-composition-example","title":"Basic Composition Example","text":"<pre><code>struct Animal {\n    name: string\n}\n\nstruct Dog {\n    // Composition instead of inheritance\n    animal: Animal,\n    breed: string,\n\n    fn bark(self) {\n        print(animal.name + \" says woof!\");\n    }\n}\n\nvar dog is Dog {\n    animal: Animal {\n        name: \"Spot\"\n        },\n    breed: \"Labrador\"\n};\n</code></pre> <p>&lt;!-- ### Modules</p> <pre><code>// math.doxa\n#safe\nexport fn add(a :: int, b :: int) -&gt; int {\n    return a + b;\n}\n\n// main.doxa\nimport { add } from \"./math.doxa\";\nvar sum is add(1, 2);\n``` --&gt;\n\n## Data Types\n\n### Basic Types\n\nStandard types include:\n\n- `int`: Integer numbers\n- `float`: Floating point numbers\n- `string`: Text strings\n- `tetra`: Four-valued logic system\n\nThe `tetra` type represents a four cornered value with the possible states: `true`, `false`, `both`, and `neither`. For additional information see the tetra page.\n\n````\n\n### Arrays\n\nArrays are homogeneous collections with type inference:\n\n```doxa\nvar nums :: int[] is [1, 2, 3];    // Explicit typing\nvar strs is [\"a\", \"b\"];            // Inferred as string[]\n\n// Invalid operations\nvar mixed is [1, \"two\", true];     // Error: mixed types\nnums.push(\"four\");                // Error: type mismatch\n````\n\n### Tuples\n\nFixed-size collections supporting heterogenus types:\n\n```doxa\nvar point is (: 10, \"hello\", true :);         // Simple tuple\nvar nested is (: (: 1, \"hello\" :), (: 3, true :) :);    // Nested tuple\n\npoint[0];                         // Access first element\nnested[1][0];                     // Access nested element\n</code></pre>"},{"location":"syntax/#maps","title":"Maps","text":"<p>String-keyed dictionaries:</p> <pre><code>var scores is {\n    \"alice\": 100,\n    \"bob\": 85\n};\nscores[\"alice\"];                  // Access value\n</code></pre>"},{"location":"syntax/#control-flow","title":"Control Flow","text":""},{"location":"syntax/#pattern-matching","title":"Pattern Matching","text":"<pre><code>enum Status { Success, Error, Pending }\n\nvar result is match status {\n    .Success =&gt; \"all good\",\n    .Error =&gt; \"failed\",\n    else =&gt; \"waiting\"\n};\n</code></pre> <p>Warning</p> <p>Match expressions must be exhaustive or include an <code>else</code> clause.</p>"},{"location":"syntax/#error-handling","title":"Error Handling","text":"<pre><code>try {\n    riskyOperation();\n} catch {\n    handleError();\n}\n</code></pre>"},{"location":"syntax/#special-operators","title":"Special Operators","text":""},{"location":"syntax/#peek-operator","title":"Peek operator (<code>?</code>)","text":"<pre><code>var x is computeValue();\nx?;                              // Prints value with location, name, and type\n</code></pre>"},{"location":"syntax/#type-information","title":"Type Information","text":"<pre><code>typeof(42);                      // \"int\"\ntypeof(\"hello\");                 // \"string\"\ntypeof([1,2,3]);                 // \"array\"\n</code></pre>"},{"location":"syntax/#collection-quantifiers","title":"Collection Quantifiers","text":"<pre><code>(\u2203x \u2208 numbers : x &gt; 10) // Logical notation\n(exists x in numbers where x &gt; 10) // English prose\n(\u2200x \u2208 numbers : x &gt; 0) // Logical notation\n(forall x in numbers where x &gt; 0) // English prose\n</code></pre>"},{"location":"syntax/#conditional-expressions","title":"Conditional Expressions","text":"<p>All conditionals are expressions and return values:</p> <pre><code>var result is if condition then {\n    value1\n} else {\n    value2\n};\n</code></pre> <p>Note</p> <p>Expressions without a value return <code>nothing</code>: <code>doxa     var x is if (false) { y is 1 };  // x becomes nothing</code></p>"},{"location":"syntax/#function-return-types","title":"Function Return Types","text":"<p>Functions can specify return types using either <code>-&gt;</code> or <code>returns</code> syntax:</p> <pre><code>fn add(a: int, b: int) -&gt; int {\n    return a + b;\n}\n\n// Alternative syntax\nfn add(a: int, b: int) returns(int) {\n    return a + b;\n}\n</code></pre> <p>return types are optional and inferred by default:</p> <pre><code>// Normal Mode - Valid\nfn add(a, b) {\n    return a + b;\n}\n</code></pre>"},{"location":"syntax/#logic","title":"Logic","text":""},{"location":"syntax/#first-order-logic","title":"First order logic","text":"<p>First order logic always produces a true or false value. For more information on tetras see the tetra page.</p> <p>Doxa has extensive for traditional first order logics that work as expected with true and false values. These can be represented in formal unicode notation:</p> <pre><code>const arr :: int[] = [1, 2, 3, 4, 5]\n\n// existential quantifier \u2203, element of \u2208\n\u2203x \u2208 arr : x &gt; 3; // true\n\n// universal quantifier \u2200, where :\n\u2200x \u2208 arr : x &gt; 3; // false\n\n// NOT \u00ac\n\u00acfalse; // true\n\n// biconditional \u2194\nfalse \u2194 false; // true\n\n// XOR \u2295\ntrue \u2295 true; // false\n\n// AND \u2227\ntrue \u2227 false; // false\n\n// OR \u2228\ntrue \u2228 false; // true\n\n// NAND \u2191\ntrue \u2191 false; // true\n\n// NOR \u2193\ntrue \u2193 false; // false\n\n// implication \u2192\ntrue \u2192 false; // false\n</code></pre> <p>This unicode support is paired with plaintext keywords which act in an identical fashion:</p> <pre><code>\u2203 - exists\n\u2200 - forall\n\u2208 - in\n: - where\n\u00ac - not\n\u2194 - iff\n\u2295 - xor\n\u2227 - and\n\u2228 - or\n\u2191 - nand\n\u2193 - nor\n\u2192 - implies\n</code></pre> <p>This means formal logical representation can be written in either way:</p> <pre><code>const arr :: int[] = [1, 2, 3, 4, 5]\n\n\u00ac(\u2200x \u2208 arr : x &gt; 3); // true\nnot (forall x in arr where x &gt; 3); // true\n</code></pre>"},{"location":"syntax/#trancendental-logic","title":"Trancendental logic","text":"<p>There are currently two trancendental operators, <code>and</code> and <code>not</code>. These can be represented by the following truth tables:</p> ^ T F B N F F B B N T B T B N B B B B N N N N N N ~ F T T F B N N B"},{"location":"syntax/#modes-of-operation-not-yet-implemented","title":"Modes of Operation (not yet implemented)","text":"<p>Doxa supports three operational modes:</p> <ul> <li>Normal Mode (default): Dynamic typing with flexible syntax</li> <li>Safe Mode: Enabled via <code>#safe</code> at file start, enforces static typing</li> <li>Warn Mode: Compiles in normal mode but warns about safe convention violations</li> </ul> <p>Note</p> <p>Safe files can only import other safe files, while normal files can import both.</p>"},{"location":"tetras/","title":"Doxa Language Reference","text":""},{"location":"tetras/#tetras","title":"Tetras","text":""},{"location":"tetras/#type-overview","title":"Type overview","text":"<p>A tetra is a type which represents four cornered logic as opposed to Booles binary logic. You can think of a tetra a bit like an extended boolean type. Where bools can only exist in only two states, true or false, tetras can exist in four. The four states which tetras can exist in are:</p> <p><code>true</code> - These first two values should be familiar <code>false</code> <code>both</code> - This is equivilant to both true and false <code>neither</code> - This is equivilatnt neither to true or false</p>"},{"location":"tetras/#an-example","title":"An Example","text":"<p>Let's start with a condition, in this case, the condition of being alive. In traditional boolean logic there would be only two states for this condition, true or false, or in term of the condition, alive or dead. But a tetra can represent logical conditions outside of this true/false, alive/dead binary.</p> <p>Here are four values to represent the four possible states or corners of a tetra:</p> <pre><code>const Bob is true;\nconst Shakespere is false;\nconst zombie is both;\nconst angel is neither;\n</code></pre> <p>Now let's create some conditional logic to understand how a tetra works. Here is a function to discover whether something is alive or not:</p> <pre><code>function living(alive :: tetra) {\n    if alive then \"I am alive\"?;\n    if not alive then \"I am dead\"?;\n}\n</code></pre> <p>Notice that if this function was in another language and was using a boolean, there would only be two possible branches when executed. If you would like to follow along, here is how I ran the values through the function:</p> <pre><code>\"Bob\"?;\nliving(Bob);\n\"Shakespere\"?;\nliving(Shakespere);\n\"zombie\"?;\nliving(zombie);\n\"angel\"?;\nliving(angel);\n</code></pre> <p>And here is the ouput I received:</p> <pre><code>[C:\\dev\\zig\\doxa\\test.doxa:11:6] value = \"Bob\"\n[C:\\dev\\zig\\doxa\\test.doxa:7:31] value = \"I am alive\"\n[C:\\dev\\zig\\doxa\\test.doxa:13:13] value = \"Shakespere\"\n[C:\\dev\\zig\\doxa\\test.doxa:8:34] value = \"I am dead\"\n[C:\\dev\\zig\\doxa\\test.doxa:15:9] value = \"zombie\"\n[C:\\dev\\zig\\doxa\\test.doxa:7:31] value = \"I am alive\"\n[C:\\dev\\zig\\doxa\\test.doxa:8:34] value = \"I am dead\"\n[C:\\dev\\zig\\doxa\\test.doxa:17:8] value = \"angel\"\n</code></pre> <p>The output here might seems strange but the logic behind it is very simple. True only triggers conditions which are true. False only triggers conditions which are false. Both will trigger both the condition regardless if it is true or false. Neither will never trigger a condition.</p> <p>This means zombie triggers both the <code>alive</code> condition and its negation <code>not alive</code>.</p> <pre><code>[C:\\dev\\zig\\doxa\\test.doxa:15:9] value = \"zombie\"\n[C:\\dev\\zig\\doxa\\test.doxa:7:31] value = \"I am alive\"\n[C:\\dev\\zig\\doxa\\test.doxa:8:34] value = \"I am dead\"\n</code></pre> <p>Angel triggers neither and so we see no output from either branch.</p> <pre><code>[C:\\dev\\zig\\doxa\\test.doxa:17:8] value = \"angel\"\n</code></pre> <p>Keep in mind, a tetra is a value. It doesn't actually alter the logic flow of your program, it's purpose is simply to follow the logic flow in ways basic true and false cannot.</p> <p>Special attention should (not) be paid to the else clause. The else clause is exactly what it sounds like - \"if a condition is ment, then do x, OR ELSE, do y\". As we now know, both will always trigger a condition, and neither will never trigger a condition. The effect with else blocks is then as you would assume, both with never trigger an else clause, and neither will always trigger an else clause.</p> <pre><code>const zombie is both;\nconst angel is neither;\n\nfunction living(alive :: tetra) {\n    if alive then \"I am alive\"? else \"I am not alive\"?;\n    if not alive then \"I am dead\"? else \"I am not dead\"?;\n}\n\n\"zombie\"?;\nliving(zombie);\n\"angel\"?;\nliving(angel);\n</code></pre> <pre><code>[C:\\dev\\zig\\doxa\\test.doxa:9:9] value = \"zombie\"\n[C:\\dev\\zig\\doxa\\test.doxa:5:31] value = \"I am alive\"\n[C:\\dev\\zig\\doxa\\test.doxa:6:34] value = \"I am dead\"\n[C:\\dev\\zig\\doxa\\test.doxa:11:8] value = \"angel\"\n[C:\\dev\\zig\\doxa\\test.doxa:5:55] value = \"I am not alive\"\n[C:\\dev\\zig\\doxa\\test.doxa:6:57] value = \"I am not dead\"\n</code></pre>"},{"location":"unions/","title":"Typed Unions","text":""},{"location":"unions/#what-are-unions","title":"What are unions","text":"<p>Unions are a special type which can represent one type or another. For instance, you can make a value that either returns a number, or a string. A union can only hold a single value, and therefore represent a single type when used.</p>"},{"location":"unions/#syntax","title":"Syntax","text":"<p>Unions are declared using the smiley face <code>(: ... :)</code> syntax:</p> <pre><code>var x :: (: int, float :);\nvar y :: (: string, int, float :);\n</code></pre> <p>The syntax consists of:</p> <ul> <li><code>(:</code> - Opening union delimiter</li> <li>A comma-separated list of types</li> <li><code>:)</code> - Closing union delimiter</li> </ul>"},{"location":"unions/#examples","title":"Examples","text":"<pre><code>// A union that can be either an integer or a float\nvar number :: (: int, float :);\nnumber is 42;     // Valid - integer\nnumber is 3.14;   // Valid - float\n\n// A union that can be a string, integer, or float\nvar value :: (: string, int, float :);\nvalue is \"hello\"; // Valid - string\nvalue is 100;     // Valid - integer\nvalue is 2.718;   // Valid - float\n\n// Unions default to the first type when not initialized\nvar defaulted :: (: int, float :);\ndefaulted?;       // Prints 0 (default int value)\n\nvar float_first :: (: float, int :);\nfloat_first?;     // Prints 0.0 (default float value)\n</code></pre>"},{"location":"unions/#default-behavior","title":"Default Behavior","text":"<p>When a union is declared without initialization, it defaults to the first type in the union with its default value:</p> <ul> <li><code>int</code> defaults to <code>0</code></li> <li><code>float</code> defaults to <code>0.0</code></li> <li><code>string</code> defaults to <code>\"\"</code></li> <li><code>tetra</code> defaults to <code>false</code></li> <li><code>nothing</code> defaults to <code>nothing</code></li> </ul> <p>This ensures that unions always have a well-defined state and the compiler knows which type is currently active.</p>"},{"location":"unions/#optional-values","title":"Optional Values","text":"<p>A common use case for unions is representing optional values using <code>nothing</code>:</p> <pre><code>// Optional integer\nvar maybe_int :: (: int, nothing :);\nmaybe_int is 42;     // Has a value\nmaybe_int is nothing; // No value\n\n// Function that might not return a value\nfn findValue(arr :: array, target :: int) :: (: int, nothing :) {\n    for (arr) |item| {\n        if (item == target) {\n            return item;\n        }\n    }\n    return nothing; // Not found\n}\n</code></pre>"},{"location":"unions/#why-unions-are-useful","title":"Why unions are useful","text":"<p>Unions are particularly useful when:</p> <ul> <li>A function can return different types depending on the input</li> <li>A variable needs to hold different types at different times</li> <li>You want to represent optional values (like <code>(: T, nothing :)</code>)</li> <li>You're working with data that can have multiple valid representations</li> </ul>"},{"location":"unions/#type-safety-tiers","title":"Type Safety Tiers","text":"<p>Doxa provides three tiers of type safety for working with unions, from most dangerous to safest:</p>"},{"location":"unions/#1-kill-critical-assertions","title":"1. Kill - Critical Assertions","text":"<p>Use when you're confident about types and want fast failure. The program halts with a detailed stack trace if the type doesn't match.</p> <pre><code>const intOrString :: (: int, string :) = getUserInput();\n\n// Explicit type assertion - halt if not int\nconst num :: int is intOrString!int kill;\n\n// Type inference - halt if type doesn't match context\nconst str is intOrString! kill;\n</code></pre> <p>Use cases: Debugging, critical paths where type mismatches indicate bugs, performance-critical code.</p>"},{"location":"unions/#2-catch-graceful-recovery","title":"2. Catch - Graceful Recovery","text":"<p>Use when you want to handle type mismatches gracefully. The <code>catch</code> block provides a fallback when the type doesn't match.</p> <pre><code>const value :: (: int, string :) = getUserInput();\n\n// Handle specific type mismatch\nconst num :: int is value!int catch {\n    log(\"Expected int, got {}\", typeof(value));\n    return 0; // Provide default value\n};\n\n// Handle any type mismatch with inferred type\nconst processed = value! catch {\n    log(\"Unexpected type: {}\", typeof(value));\n    return handleUnexpectedType(value);\n};\n</code></pre> <p>Key points:</p> <ul> <li>The <code>catch</code> block executes only when the type doesn't match</li> <li>You can return any value from the <code>catch</code> block</li> <li>The <code>catch</code> block has access to the original union value</li> </ul>"},{"location":"unions/#3-match-exhaustive-safety","title":"3. Match - Exhaustive Safety","text":"<p>Use for complete type safety and handling all possible cases. The <code>as</code> keyword provides a typed variable for each case.</p> <pre><code>const result = addLimit(100, 200);\n\n// Exhaustive matching with typed variables\nmatch result as x {\n    .int =&gt; {\n        // x is typed as int here\n        onlyUsesInts(x);\n    },\n    .errorList =&gt; {\n        // x is typed as errorList here\n        handleError(x);\n    }\n}\n</code></pre> <p>Key points:</p> <ul> <li><code>as</code> provides a typed variable for each match arm</li> <li>The variable is automatically typed to the matched variant</li> <li>Exhaustive matching ensures all cases are handled</li> <li>You can destructure complex unions with multiple variables</li> </ul>"},{"location":"unions/#error-handling-with-unions","title":"Error Handling with Unions","text":"<p>Unions combine with enums for expressive error handling without dedicated error types:</p> <pre><code>// Define error types as enums\nenum MathError {\n    Overflow,\n    Underflow,\n    DivisionByZero,\n}\n\n// Function returns union of success or error\nfn safeDivide(a :: int, b :: int) :: (: int, MathError :) {\n    if (b == 0) return MathError.DivisionByZero;\n    if (a &gt; 255) return MathError.Overflow;\n    if (a &lt; 0) return MathError.Underflow;\n    return a / b;\n}\n\n// Handle errors using any tier\nconst result = safeDivide(100, 0);\n\n// Tier 1: Kill on error\nconst value :: int is result!int kill;\n\n// Tier 2: Catch and handle\nconst value :: int is result!int catch {\n    log(\"Math error occurred\");\n    return 0;\n};\n\n// Tier 3: Exhaustive handling\nmatch result as x {\n    .int =&gt; {\n        processResult(x);\n    },\n    .MathError =&gt; {\n        handleMathError(x);\n    }\n}\n</code></pre>"},{"location":"unions/#pattern-matching-details","title":"Pattern Matching Details","text":""},{"location":"unions/#the-as-keyword","title":"The <code>as</code> Keyword","text":"<p>The <code>as</code> keyword in pattern matching provides typed variables:</p> <pre><code>const union :: (: int, string, float :) = \"hello\";\n\n// Single variable\nmatch union as x {\n    .int =&gt; processInt(x),      // x is typed as int\n    .string =&gt; processString(x), // x is typed as string\n    .float =&gt; processFloat(x),   // x is typed as float\n}\n</code></pre>"},{"location":"unions/#exhaustiveness","title":"Exhaustiveness","text":"<p>Match expressions must be exhaustive or include an <code>else</code> clause:</p> <pre><code>const value :: (: int, string :) = \"hello\";\n\n// Exhaustive - handles all cases\nmatch value as x {\n    .int =&gt; handleInt(x),\n    .string =&gt; handleString(x),\n}\n\n// Non-exhaustive with else\nmatch value as x {\n    .int =&gt; handleInt(x),\n    else =&gt; handleOther(x),\n}\n</code></pre>"},{"location":"unions/#best-practices","title":"Best Practices","text":"<ol> <li>Prefer Match: Use exhaustive matching for maximum safety</li> <li>Use Catch for Recovery: When you need graceful fallbacks</li> <li>Reserve Kill for Debugging: Only use kill assertions in development or critical paths</li> <li>Be Explicit: Always specify the behavior you want rather than relying on defaults</li> <li>Handle All Cases: Use exhaustive matching when possible to catch all edge cases</li> </ol>"}]}