{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Doxa","text":"<p>Doxa is a compiled language which focuses on simplicity, readability, and gradualized type safety. It enables seamless transition from prototype to production code through strict and normal directives.</p> <p>Doxa is built using Zig. It's designed to be a highly readable language that brings gradual type safety which is controlled by directives. This allows Doxa to act as a flexible and dynamically typed scripting language while providing the ability to enforce type safety when needed.</p> <p>Here is a comparison of a simple program written in Doxa's normal mode vs strict mode:</p> <pre><code>var x = 1;\nvar y = 2;\n\nfn add(a, b) {\n    return (a + b);\n}\n\nadd(x, y);\n</code></pre> <pre><code>#strict\n\nfn add(a: int, b: int) returns(int) {\n    return (a + b);\n}\n\n-&gt; fn main() {\n    var a: int = 1;\n    var b: int = 2;\n\n    add(a, b);\n}\n</code></pre> <p>The normal mode is a superset of the strict mode. This means that any valid strict mode code is also valid normal mode code. Transition from prototype to production code is aided by the use of the <code>#warn</code> directive. Warn mode will compile the code in normal mode but provides warnings where strict syntax isn't followed.</p>"},{"location":"syntax/","title":"Syntax","text":"<p>By default, Doxa runs in normal mode. Strict mode is enabled via <code>#strict</code> at the file start. To preserve type safety, strict files can only import other strict files. There is an intermediate mode called <code>warn</code> which compiles files in normal mode but gives warnings when strict conventions are not followed.</p>"},{"location":"syntax/#general-syntax","title":"General syntax","text":"<p>both <code>||</code> and <code>&amp;&amp;</code> are supported alongside <code>and</code> and <code>or</code>. a clarity warning is given if both are used in the same file.</p> <p>No operator or function overloading.</p> <p>TODO: Memory management is handled via garbage collection.</p> <p>No classes, only structs and composition.</p> <p>Doxa has some choice code keywords:</p> <ul> <li><code>function</code> and <code>fn</code> are functionally identical</li> <li><code>and</code> and <code>&amp;&amp;</code> are functionally identical</li> <li><code>or</code> and <code>||</code> are functionally identical</li> <li><code>equals</code> and <code>==</code> are functionally identical</li> <li><code>where</code> and <code>|</code> are functionally identical</li> </ul> <p>Warnings are given for projects that mix alternate tokens.</p> <pre><code>struct Animal {\n    name: string\n}\n\nstruct Dog {\n    // Composition instead of inheritance\n    animal: Animal,\n    breed: string,\n\n    fn bark(self) {\n        print(\"${self.animal.name} says woof!\");\n    }\n}\n\nvar dog = Dog {\n    animal: Animal { name: \"Spot\" },\n    breed: \"Labrador\"\n};\n</code></pre> <p>TODO: Modules are supported. strict files can only import other strict files. normal files can import both strict and normal files.</p> <pre><code>// math.doxa\n#strict\n\n// Explicit exports\nexport fn add(a: int, b: int) -&gt; int {\n    return a + b;\n}\n\n// main.doxa\nimport { add } from \"./math.doxa\";\n\n// Explicit usage\nvar sum = add(1, 2);\n</code></pre> <p>match is supported. all cases must be exhaustive but else is supported as a fallback.</p> <pre><code>enum Number {\n    ZERO,\n    ONE,\n    UNKNOWN\n}\n\nswitch x {\n    .ZERO =&gt; print(\"zero\"),\n    .ONE =&gt; print(\"one\"),\n    .UNKNOWN =&gt; print(\"unknown\")\n}\n\n// this is functionally identical to the previous example\nswitch x {\n    .ZERO =&gt; print(\"zero\"),\n    .ONE =&gt; print(\"one\"),\n    .UNKNOWN =&gt; print(\"unknown\")\n}\n</code></pre> <p>all cases must be covered</p> <pre><code>//this is an error, as one or more cases are not covered\nmatch x {\n    .ZERO =&gt; print(\"zero\"),\n    .ONE =&gt; print(\"one\"),\n}\n</code></pre> <p>try catch is supported</p> <pre><code>var x = 0;\ntry {\n    var x = 1 / x;\n} catch {\n    handle_error();\n}\n</code></pre> <p>arrays can only be declared with a homogeneous type. Heterogeneous arrays are not supported. Structs are the preferred way to group different types.</p> <pre><code>// Only homogeneous arrays allowed\nvar nums: int[] = [1, 2, 3];       // OK\nvar strs: string[] = [\"a\", \"b\"];   // OK\n\n// These would be errors\nvar mixed = [1, \"two\", true];      // Error: mixed types in array\nvar noType = [1, 2, 3];            // Error: array type must be explicit\n</code></pre> <p>tuples are supported</p> <pre><code>var x = (1, 2, 3);\nx[0]; // 1\nx[1]; // 2\nx[2]; // 3\n</code></pre> <p>mapping is supported</p> <pre><code>var x = {\n    \"a\": 1,\n    \"b\": 2,\n    \"c\": 3\n};\nx[\"a\"]; // 1\nx[\"b\"]; // 2\nx[\"c\"]; // 3\n</code></pre> <p>there are xor, existensial quantifiers, and universal quantifiers</p> <pre><code>var a = true xor false;\nvar b = exists i in [1, 2, 3] where i &gt; 1;\nvar c = forall i in [1, 2, 3] | i &gt; 1;\n</code></pre> <p>Doxa has an inspect operator <code>?</code> which can be used to inspect the value of any expression.</p> <pre><code>var x = 1;\nx?; // prints [main.doxa:1:1] x = 1\n</code></pre>"},{"location":"syntax/#doxa-normal-syntax","title":"Doxa normal syntax","text":"<p>in normal mode, all variables are dynamically typed by default. this can be explicitly marked with the auto type. this allows for cross type assignments.</p> <pre><code>var x = 1;                //int\nx = true;                 //bool\n\nvar x: auto = 3.14;      //float\nx = \"pi\";                //string\n</code></pre> <p>constants are declared with the const keyword</p> <pre><code>const x = 1;              //int\nconst x = \"two\";          //string\nconst x = [1, 2, 3];      //array\n</code></pre> <p>constants cannot be declared without a value but type can be inferred like variables.</p> <pre><code>const x;                  //error, needs a value\nconst x = 1;              //int\nconst y: auto = 3.14;    //float\n</code></pre> <p>type declarations are allowed. when a type is declared safety is enforced.</p> <pre><code>var x: int = 1;           //int\nx = \"two\";                //error, expected type int\n</code></pre> <p>variables can be declared without a value</p> <pre><code>var x: int;               //int\nvar x: string;            //string\nvar x: float;             //float\nvar x: bool;              //bool\nvar x: []int;             //array\n</code></pre> <p>variables can be declared without a type</p> <pre><code>var x;                    //auto\nvar x: auto;              //auto\n</code></pre> <p>cross-type assignments are allowed for auto variables</p> <pre><code>var x = 5;                //auto\nx = \"five\";               //auto\n</code></pre> <p>arrays can be declared either with a homogeneous type or a mixed type</p>"},{"location":"syntax/#doxa-strict-syntax","title":"Doxa strict syntax","text":"<p>constants must be declared with a type and a value</p> <pre><code>const x;                  //error, needs a type and a value\nconst x: int;             //error, needs a value\n</code></pre> <p>variables can be declared without a value as long as they are given an explicit type. if a variable is declared without a type, it and error is thrown. There is an auto type which can be used however type safety is still enforced.</p> <pre><code>var x: int;               //int\nvar x = \"two\";            //error, needs explicit type\nvar x: auto = 3.14;       //float\n</code></pre> <p>variables can be declared without a value as long as they are given an explicit type</p> <pre><code>var x: int;               //int\nvar x: string;            //string\nvar x: float;             //float\nvar x: bool;              //bool\nvar x: []int;             //array\n</code></pre> <p>variables cannot be declared without a type</p> <pre><code>var x;                    //error, needs explicit type\nvar x: auto;              //error, needs explicit type\n</code></pre> <p>Auto will default the variable to the type of the initial value. no cross-type assignments are allowed for strict variables</p> <pre><code>var x: auto = 5;          //int\nx = \"five\";               //error, given value does not match type int\n</code></pre> <p>Arrays must be explicitly typed.</p> <pre><code>var x: int[] = [1, 2, 3];   //OK\nvar x = [1, 2, 3];         //error, needs explicit type\n</code></pre>"},{"location":"syntax/#conditionals","title":"Conditionals","text":"<p>In Doxa, all conditionals are expressions, so they return a value. this allows a unified syntax for conditionals and assignments.</p> <p>All of the following are functionally equivalent:</p> <pre><code>var a;\nif false then a is 5\nelse if true then a is 20\nelse a is 30;\n\nvar b;\nif (false) then {b = 5;}\nelse if (true) then {b = 20;}\nelse {b = 30;}\n\nvar c is\nif false then 5\nelse if true then 20\nelse 30;\n\nvar d =\nif (false) then {5;}\nelse if (true) then {20;}\nelse {30;};\n</code></pre> <p>if an if expression doesn't return a value, it defaults to <code>nothing</code>.</p> <pre><code>var x = if (y == 1) { y = 1 } else { y = 2 };\nprint(x); // prints the 'nothing' value\n\nvar x = if (false) { y = 1 } else {};\nprint(x); // prints the 'nothing' value\n</code></pre> <p>if statements without an else branch default to <code>nothing</code>. the following are functionally equivalent:</p> <pre><code>var x = if (false) { y = 1 }; // warning raised about possible 'nothing' return value\nvar x = if (false) { y = 1 } else nothing;\n</code></pre>"}]}