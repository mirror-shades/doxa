{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Doxa","text":"<p>Doxa is a highly flexible compiled language focused on simplicity, readability, and gradualized type safety. It enables seamless transition from prototype to production code through strict and normal directives. </p> <p>Doxa is built using Zig. It's designed to be a highly readable language that brings gradual type safety which is controlled by directives. This allows Doxa to act as a flexible and dynamically typed scripting language while providing the ability to enforce type safety when needed.</p> <p>Here is a comparison of a simple program written in Doxa's normal mode vs strict mode:</p> <pre><code>var x = 1;\nvar y = 2;\n\nfn add(a, b) {\n    return (a + b);\n}\n\nadd(x, y);\n</code></pre> <pre><code>#strict\n\nfn add(a: int, b: int) returns(int) {\n    return (a + b);\n}\n\n-&gt; fn main() {\n    var a: int = 1;\n    var b: int = 2;\n\n    add(a, b);\n}\n</code></pre>"},{"location":"syntax/","title":"Syntax","text":"<p>By default, Doxa runs in normal mode. Strict mode is enabled via <code>#strict</code> at the file start. To preserve type safety, strict files can only import other strict files. There is an intermediate mode called <code>warn</code> which compiles files in normal mode but gives warnings when strict conventions are not followed.</p>"},{"location":"syntax/#general-syntax","title":"General syntax","text":"<p>both <code>||</code> and <code>&amp;&amp;</code> are supported alongside <code>and</code> and <code>or</code>. a clarity warning is given if both are used in the same file.</p> <p>No operator or function overloading.</p> <p>Memory management is handled via garbage collection.</p> <p>No classes, only structs and composition.</p> <p>Try catch is based on Zig's error union model which allows for safer error handling.</p> <pre><code>fn divide(a: int, b: int) !int {\n    if (b == 0) return error.DivisionByZero;\n    return a / b;\n}\n\n// Usage\nvar result = try divide(10, 0);\n// or\nvar result = divide(10, 0) catch |err| {\n    log.error(\"Failed to divide: {}\", err);\n    return;\n};\n</code></pre> <p>Doxa has some choice code keywords: - <code>function</code> and <code>fn</code> are functionally identical - <code>and</code> and <code>&amp;&amp;</code> are functionally identical - <code>or</code> and <code>||</code> are functionally identical</p> <p>warnings are given for projects that mix symbolic and keyword conditionals.</p> <pre><code>struct Animal {\n    name: string\n}\n\nstruct Dog {\n    // Composition instead of inheritance\n    animal: Animal,\n    breed: string,\n\n    fn bark(self) {\n        print(\"${self.animal.name} says woof!\");\n    }\n}\n\nvar dog = Dog {\n    animal: Animal { name: \"Spot\" },\n    breed: \"Labrador\"\n};\n</code></pre> <p>modules are supported. strict files can only import other strict files. normal files can import both strict and normal files.</p> <pre><code>// math.doxa\n#strict\n\n// Explicit exports\nexport fn add(a: int, b: int) -&gt; int {\n    return a + b;\n}\n\n// main.doxa\nimport { add } from \"./math.doxa\";\n\n// Explicit usage\nvar sum = add(1, 2);\n</code></pre> <p>match is supported rather than switch.</p> <pre><code>enum Number {\n    ONE,\n    TWO,\n    UNKNOWN\n}\n\nmatch x {\n    .ONE =&gt; print(\"one\"),\n    .TWO =&gt; print(\"two\"),\n    .UNKNOWN =&gt; print(\"unknown\")\n}\n</code></pre> <p>else is supported</p> <pre><code>// this is functionally identical to the previous example\nmatch x {\n    .ONE =&gt; print(\"one\"),\n    .TWO =&gt; print(\"two\"),\n    else =&gt; print(\"unknown\")\n}\n</code></pre> <p>all cases must be covered</p> <pre><code>//this is an error, as one or more cases are not covered\nmatch x {\n    .ONE =&gt; print(\"one\"),\n    .TWO =&gt; print(\"two\")\n}\n</code></pre> <p>arrays can only be declared with a homogeneous type. Heterogeneous arrays are not supported. Structs are the preferred way to group different types.</p> <pre><code>// Only homogeneous arrays allowed\nvar nums: []int = [1, 2, 3];       // OK\nvar strs: []string = [\"a\", \"b\"];   // OK\n\n// These would be errors\nvar mixed = [1, \"two\", true];      // Error: mixed types in array\nvar noType = [1, 2, 3];            // Error: array type must be explicit\n</code></pre>"},{"location":"syntax/#doxa-normal-syntax","title":"Doxa normal syntax","text":"<p>constants are declared with the const keyword</p> <pre><code>const x = 1;              //int\nconst x = \"two\";          //string\nconst x = 3.14;           //float\nconst x = true;           //bool\nconst x = [1, 2, 3];      //array\n</code></pre> <p>constants cannot be declared without a value</p> <pre><code>const x;                  //error, needs a value\n</code></pre> <p>all variables are auto by default</p> <pre><code>var x = 1;                //auto\nvar x = \"two\";            //auto\nvar x = 3.14;             //auto\nvar x = true;             //auto\nvar x = [1, 2, 3];        //auto\n</code></pre> <p>type declarations are allowed</p> <pre><code>var x: int = 1;           //int\nvar x: string = \"two\";    //string\nvar x: float = 3.14;      //float\nvar x: bool = true;       //bool\nvar x: []int = [1, 2, 3]; //array\n</code></pre> <p>variables can be declared without a value</p> <pre><code>var x: int;               //int\nvar x: string;            //string\nvar x: float;             //float\nvar x: bool;              //bool\nvar x: []int;             //array\n</code></pre> <p>variables can be declared without a type</p> <pre><code>var x;                    //auto\nvar x: auto;              //auto\n</code></pre> <p>cross-type assignments are allowed for auto variables</p> <pre><code>var x = 5;                //auto\nx = \"five\";               //auto\n</code></pre> <p>arrays can be declared either with a homogeneous type or a mixed type</p>"},{"location":"syntax/#doxa-strict-syntax","title":"Doxa strict syntax","text":"<pre><code>const x;                  //error, needs a type and a value\nconst x: int;             //error, needs a value\n</code></pre> <p>constants can be declared with an auto type</p> <pre><code>const x: auto;            //auto\n</code></pre> <p>variables can be declared without a value as long as they are given an explicit type</p> <pre><code>var x: int;               //int\nvar x = \"two\";            //error, needs explicit type\nvar x = 3.14;             //error, needs explicit type\nvar x = true;             //error, needs explicit type\nvar x = [1, 2, 3];        //error, needs explicit type\n</code></pre> <p>type declarations are required, same as normal syntax</p> <pre><code>var x: int = 1;           //int\nvar x: string = \"two\";    //string\nvar x: float = 3.14;      //float\nvar x: bool = true;       //bool\nvar x: []int = [1, 2, 3]; //array\n</code></pre> <p>variables can be declared without a value as long as they are given an explicit type</p> <pre><code>var x: int;               //int\nvar x: string;            //string\nvar x: float;             //float\nvar x: bool;              //bool\nvar x: []int;             //array\n</code></pre> <p>auto variables can be declared without a type but it is cast to the type of the value</p> <pre><code>var x: auto = 5;          //int\nvar x: auto = \"five\";     //string\nvar x: auto = 3.14;       //float\nvar x: auto = true;       //bool\nvar x: auto = [1, 2, 3];  //array\n</code></pre> <p>variables cannot be declared without a type</p> <pre><code>var x;                    //error, needs explicit type\nvar x: auto;              //error, needs explicit type\n</code></pre> <p>no cross-type assignments are allowed for strict variables</p> <pre><code>var x: auto = 5;          //int\nx = \"five\";               //error, given value does not match type int\n</code></pre>"},{"location":"syntax/#conditionals","title":"Conditionals","text":"<p>In Doxa, all conditionals are expressions, so they return a value. this allows a unified syntax for conditionals and assignments.</p> <p>All of the following are functionally equivalent:</p> <pre><code>var x = if y == 1 then 1 else 2;\n\nvar x = if (y == 1) then 1 else 2;\n\nvar x = if (y == 1) then { 1 } else { 2 };\n\nvar x;\nif y == 1 then x = 1 else x = 2;\n\nvar x;\nif (y == 1) then x = 1 else x = 2;\n\nvar x;\nif (y == 1) then { x = 1 } else { x = 2 };\n</code></pre> <p>if an if expression doesn't return a value, it defaults to <code>nothing</code>.</p> <pre><code>var x = if (y == 1) { y = 1 } else { y = 2 };\nprint(x); // prints the 'nothing' value\n\nvar x = if (false) { y = 1 } else {};\nprint(x); // prints the 'nothing' value\n</code></pre> <p>if statements without an else branch default to <code>nothing</code>. the following are functionally equivalent:</p> <pre><code>var x = if (false) { y = 1 }; // warning raised about possible 'nothing' return value\nvar x = if (false) { y = 1 } else nothing;\n</code></pre>"}]}